\documentclass[../paper.tex]{subfiles}

\begin{document}
\section{The Main Algorithm}

In order to describe the algorithm in this section, we need to
develop more definitions and theorems. Let $d$ be an integer
greater than 2. We define the set $\mathcal{P}_d$ as follows: 
Suppose that $P$ is an increasing sequence of odd primes with 
$d$ elements. Such a sequence $P$ is a member of 
$\mathcal{P}_d$ if and only if there exists some OPAN $n$ in the 
form $n = \nu (P, E)$ for some sequence of positive integers $E$.
Note that the set $\mathcal{P}_d$ is finite as there exists only 
finitely many OPANs with $d$ divisors{\cite{dickson}}.

Let $P$ be an element of $\mathcal{P}_d$ for some integer $d \geq 
3$. We define the set of positive integer sequences 
$\mathcal{E}_P$ as 
%
$$\mathcal{E}_P = \{E\, |\, \nu(P, E) \text{ is an OPAN}\}.$$
%

Now we want to develop an ordering on $\mathcal{P}_d$. We will use
a lexicographical ordering, comparing each element sequentially.
Let $P, Q \in \mathcal{P}_d$. Write $P = \{p_0, p_1, ..., p_{d-1}\}$
and $Q = \{q_0, q_1, ..., q_{d-1}\}$. We say that $P < Q$ if 
there exists some index $i$ such that $p_i < q_i$ and for each
index $k < i$ we have that $p_k = q_k$. Naturally, we say that 
$P \leq Q$ if $P < Q$ or $P = Q$. 

Recall that we defined an integer $n$ to be $P$-initiated if the
smallest $|P|$ prime factors of $n$ compose $P$. We now generalize
this notation to include both integers and sequences. Suppose $Q$
is a sequence of $d$ elements and $P$ is a sequence of $i < d$
elements. We say that $Q$ is $P$-initiated if the first $i$
elements of $Q$ is the sequence $P$.

Suppose $P \in \mathcal{P}_d$. We define $lex(P)$ to be the set
of all $Q \in \mathcal{P}_d$ such that $Q < P$. For example,  
$lex(\{3,5,13\}) = \{\{3, 5, 7\}, \{3, 5, 11\}\}$.

\begin{theorem} \label{opan_alg}
The following algorithm determines all primitive
abundant odd numbers with $d$ divisors, for any integer $d \geq 3$.
\end{theorem}

%-----------------------------------------------------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{The Main Algorithm}
%\textit{Prerequisite: This algorithm requires all previous cases }

\textbf{INPUT:} A positive integer, $d$.
\textbf{OUTPUT:} All OPAN's with $d$ prime factors.
}

\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}[1]
%E represents exponents
\STATE For all $Q$, set $T(Q) = false$
\STATE $P := \{\}$
\STATE $running := TRUE$
\WHILE {$running$}
  \IF {$|P| \neq d$}
    \IF {$b_1(P) \geq 2$}
      \STATE Remove the last element of P
      \STATE Let $q$ be the minimum prime s.t. $b_1(P + q) < 2$
      \STATE $P := P + q$
    \ENDIF  
    \STATE Let $s$ be the minimum odd prime such that $s > max(P)$ and
$P + s$ has never been stored in $P$ before.
    \STATE $P:= P + s$ \label{main::inc_prime}
    \STATE \textbf{continue}
  \ENDIF
  \IF {$b_{\infty}(P) \leq 2$}
    \STATE $fail(P, running)$
    \STATE \textbf{continue}
  \ENDIF
  \IF {$\mathcal{E}_P$ is not empty}
    \STATE Store $(P, \mathcal{E}_P)$ \label{main::store}
    \STATE $r = nextprime(max(P))$
    \STATE Replace the last prime in $P$ with r \label{main::inc_last}
    \STATE \textbf{continue}
  \ENDIF
  \STATE $s = backup(P)$
  \IF {$|P| = d - 1$}
    \STATE $fail(P, running)$
    \STATE \textbf{continue}
  \ENDIF
  \IF {$s \leq Cap_d(P)$}
    \STATE P := P + nextprime(s) \label{main::pit}
    \STATE \textbf{contiue}
  \ENDIF
  \STATE $fail(P, running)$ \label{main::last_fail}
\ENDWHILE
\end{algorithmic}
\end{minipage}}
%----------------------------------------------------------------

%-----------------------------------------------------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{fail}
%\textit{Prerequisite: This algorithm requires all previous cases }

\textbf{INPUT:} An increasing sequence of primes $P$ and a boolean
variable $running$.

\textbf{OUTPUT:} No output. Modifies inputs.
}

\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}[1]

\STATE $P' := P$
\WHILE {$P' \neq \{\}$}
  \STATE Remove the last prime from $P'$
  \IF {there exists A P'-initiated OPAN in $lex(P)$}
    \STATE \textbf{break}
  \ENDIF
\STATE $T(P') := TRUE$
\ENDWHILE
\IF {$P' = \{\}$}
  \STATE $running := FALSE$
  \RETURN
\ENDIF 
\WHILE {$T(P')$}
  \STATE Remove the last prime from $P'$.
\ENDWHILE
\STATE $P := P'$
\RETURN
\end{algorithmic}
\end{minipage}}
%-----------------------------------------------------------

%-----------------------------------------------------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{backup}
%\textit{Prerequisite: This algorithm requires all previous cases }

\textbf{INPUT:} An increasing sequence of primes $P$.

\textbf{OUTPUT:} The last prime removed from $P$.
}

\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}[1]

\STATE $P' := P$
\WHILE {$P' \neq \{\}$}
  \STATE $q := Max(P')$
  \STATE Remove the last prime from $P'$
  \IF {there exists A P'-initiated OPAN in $lex(P)$}
    \STATE \textbf{break}
  \ENDIF
\ENDWHILE
\RETURN $q$
\end{algorithmic}
\end{minipage}}

\begin{proof}
It is noteworthy that this algorithm works in the lexicographical
order defined on $\mathcal{P}_d$. We will leverage this so that we
can induct on $\mathcal{P}_d$, showing that each member $Q \in 
\mathcal{P}_d$ will be recorded with its associated exponent 
sequences $\mathcal{E}_Q$.


We will show that $P_0 = min(\mathcal{P}_d)$ is stored with its associated 
  exponent sequences. As $Cap_{d}$ is the an upper bound to the primes in $P_0$, the algorithm will search until it reaches $Cap_{d}$.


Our base case for the proof is to show that $min(\mathcal{P}_d)$
is stored with its associated exponent sequences. For the cases $d
= 3, 4, 5, 6$, this can be done computationally. 


Our inductive step is as follows. Suppose $Q, R$ are elements in 
$\mathcal{P}_d$ such that $Q$ is the unique predecessor to $R$. If
$(Q, \mathcal{E_Q})$ is collected in the algorithm, then $(R,
\mathcal{E}_R)$ is collected in the algorithm. 

Suppose that $Q$ and $R$ are the same sequence apart from 
their respective last primes $q$ and $r$ respectively. By Corollary 
\ref{Continuity}, we have $r$ is the prime successor to $q$. When 
the algorithm collects $(Q, \mathcal{E}_Q)$ in line \ref{main::store}, 
the algorithm will immediately move on to transform $P := Q$ into $P := R$.
Following the algorithm step by step will show that $(R, \mathcal{E}_R)$ 
is collected.

Now suppose that $Q$ and $R$ are not the same sequence when ignoring the 
last element of $Q$ and $R$. Thus $Q$ and $R$ are in the form 
\begin{equation}
\begin{split}
Q = \{q_0, q_1, ..., q_{c-1}, & q_c, q_{c+1}, ..., q_d\} \\
R = \{q_0, q_1, ..., q_{c-1}, & r_c, r_{c+1}, ..., r_d\}
\end{split}
\end{equation}
where $q_c < r_c$. As there is no $S \in \mathcal{P}_d$ such that
$Q < S < R$, we can see that the algorithm will keep failing on line
\ref{main::last_fail}, until $P = \{q_0, q_1, ..., q_{c-1}\}$
The algorithm will then try the next prime $s$ 
after $q_c$ on line \ref{main::inc_prime}. Suppose  $r = r_c$. It can
be shown that from here that the algorithm 
will collect $(R, \mathcal{E}_R)$.

Henceforth assume that $nextprime(q_c) < r_c$. By Theorem \ref{cap}, 
we have that $r_c \leq cap_d{P}$. Thus the algorithm will increment its last
element as it will continue to execute the line \ref{main::pit}  
until the last prime of $P$ is equal to $r_c$ It can
be shown that from here that the algorithm 
will collect $(R, \mathcal{E}_R)$.
\\

THIS PROOF NEEDS WORK.
\end{proof}


%Todo : Start writing up algorithm in notebook.
%\begin{proof}
%Line {\ref{line:inc_last}}
%We will use induction to prove this theorem, but we must first
%find some sequence to induct on.

%We define the set of sequences of increasing odd prime $\mathcal{P}_d$.
%Let $P$ be an increasing sequence of $d$ primes. Then $P \in
%\mathcal{P}_d$ if there exists a $P$-initiated OPAN with $d$
%divisors. Note that $\mathcal{P}_d$ is finite as the number of OPAN's
%with $d$ divisors is finite\cite{dickson}. Now consider the
%lexicographical order of $\mathcal{P}_d$. As this set is finite,
%the lexicographical order is a total order, and thus each element
%of $\mathcal{P}$ has a unique predecessor and a unique successor,
%unless it is the maximum or minimum element of $\mathcal{P}$.

%It is noteworthy that the algorithm works in lexicographical
%order, i.e., whenever $P$ is modified in the algorithm, the result
%is a sequence of primes that is lexicograpically greater than $P$.

%Let $M$ be the least element of $\mathcal{P}_d$. Our base case
%for induction is: \textit{The algorithm collects all OPAN's with
%prime divisors $M$}. However, all we need to show is that our algorithm
%reaches step 4, where the exponent algorithm is used.

%TODO : base case

%Now suppose that $P, Q \in \mathcal{P}$ such that $P$ is the
%lexicographical predecessor of $Q$ in $\mathcal{P}$. Our inductive
%step is: \textit{If the algorithm collects all OPAN's with prime
%divisors composing $P$, then the algorithm collects all OPAN's with
%prime divisors composing $Q$}.

%We want to consider two cases. One case is where $P$ and $Q$ share
%all primes except the last primes. The other case is when there
%exists the nonnegative integer $i < d - 1$ such that $p_i <
%q_i$ (\textit{where $p_i, q_i$ are the ith elements in the
%sequences $P$, $Q$ respectivly}).

%If $P$ and $Q$ share all but the last prime divisor, it is easy to
%show that $max(Q)$ is the sequential prime after $max(P)$ using
%Theorem {\ref{Continuity}}. The algorithm will thus immedientl
%find all $Q$-initiated OPAN's with $d$ divisors.

%Now suppose that $P$ and $Q$ share only $c < d - 1$ sequential 
%primes, i.e., $P = \{ p_0, p_1, ..., p_{c - 1}, p_c, ..., p_{d-1}\}$
%and $Q = \{p_0, p_1, ..., p_{c - 1}, q_c, ..., q_{d - 1}\}$. We
%require that $p_c < q_c$, but there are requirements of $p_k$
%and $q_k$ for $c + 1 \leq k \leq d - 1$. When the algorithm
%reaches the step where $P := P$, we want to show that the
%algorithm will transform $P$ to $Q$. 

%Note that, after step $5$, the algorithm replaces $p_{d-1}$ with
%its sucessor $p'_{d - 1}$. Here the algorithm fail at step 3 or
%the algorithm will fail at step 7. When the failure procedure acts
%on $P$, exactly one prime will be removed. In fact, this will
%happen until $P := \{p_0, p_1, ..., p_{c-1}\}$. 

%If the next prime after $p_c$ is $q_c$, then the algorithm will
%append $q_c$, setting $P := P + q_c$. 

%If the next prime after $p_c$ is not $q_c$, then $p_c \leq
%Cap_d(P)$ by Theorem {\ref{cap}}. Also, $q \leq
%nextprime(Cap_d(P)) $ by Theorem $4.5$. As the algorithm does not
%stop checking primes until $p_c \geq nextprime(Cap_d(P))$, we have
%that the algorithm will find $q_c$. 

%Thus we will have that $P = \{p_0, p_1, ..., p_{c-1}, q_c\}$.

%Now we need to show that the algorithm collects all $Q$-initiated
%OPAN's with $d$ divisors, starting with the $P$ we have achieved
%above.

%For each $q_i$ such that $c < i < d - 1$, we have that $q_i \leq
%nextprime(Cap_d(Q_i))$, where $Q_i = \{p_0, p_1, ..., p_{c-1},
%q_c, ..., q_{i - 1}\}$. This is the combination of Theorem
%{\ref{cap}} and the fact that there is no sequence of $d$ primes 
%$R$ such that $P < R < Q$ and there exists some $R$-initiated
%OPAN. As the algorithm will not stop checking primes until this
%point, we have that the algorithm will add $q_i$ to $Q_i$ for any
%$c < i < d - 1$. Thus the algorithm will find all $Q$-initiated
%OAPN's with $d$ divisors, completing the inductive step.
%\end{proof}

\end{document}
