\documentclass[../paper.tex]{subfiles}

\begin{document}
\section{The Main Algorithm}

The following set of instructions is the algorithm that determines
all primitive abundant odd numbers with $d$ divisors. Thus the
input is $d$, and the algorithm will record all OPN's with $d$
divisors.

\begin{theorem} The following algorithm determines all primitive
abundant odd numbers with $d$ divisors.
\end{theorem}


Start with $P = \{\}$. Also, set $state = running$.

%-----------------------------------------------------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{The Main Algorithm}
%\textit{Prerequisite: This algorithm requires all previous cases }

\textbf{INPUT:} A positive integer, $d$.
\textbf{OUTPUT:} All OPN's with $d$ prime factors.
}
\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}
%E represents exponents
\STATE $P := \{\}$
\STATE $running := TRUE$
\WHILE {$running$}
  \IF {$|P| \neq d$}
    \IF {$b_1(P) \geq 2$}
      \STATE Remove the last element of P.
      \IF {$b_1(P) \geq 2$}
        \STATE Return "Error" (This step should never happen  --
Proven in proof)
      \ENDIF
      \STATE Let $q$ be the minimum prime s.t. $b_1(P + q) < 2$
      \STATE $P := P + q$
      \STATE \textbf{continue}
    \ENDIF
  \ENDIF
  \IF {$b_{\infty}(P) \leq 2$}
    \STATE $fail(P, running)$
    \STATE \textbf{continue}
  \ENDIF
  \IF {$\mathcal{E}_P$ is not empty}
    \STATE $r = nextprime(max(P))$
    \STATE Replace the last prime in $P$ with r
    \STATE \textbf{continue}
  \ENDIF
  \STATE $s = backup(P)$
  \IF {$|P| = d - 1$}
    \STATE $fail(P, running)$
    \STATE \textbf{continue}
  \ENDIF
  \IF {$s \leq Cap_d(P)$}
    \STATE P := P + nextprime(s)
    \STATE \textbf{contiue}
  \ENDIF
  \STATE fail(P, running)
\ENDWHILE
\end{algorithmic}
\end{minipage}}
%----------------------------------------------------------------

%-----------------------------------------------------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{fail}
%\textit{Prerequisite: This algorithm requires all previous cases }

\textbf{INPUT:} A positive integer, $d$.
\textbf{OUTPUT:} All OPN's with $d$ prime factors.
}
\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}

\STATE PASS
\end{algorithmic}
\end{minipage}}
%-----------------------------------------------------------

%-----------------------------------------------------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{backup}
%\textit{Prerequisite: This algorithm requires all previous cases }

\textbf{INPUT:} A positive integer, $d$.
\textbf{OUTPUT:} All OPN's with $d$ prime factors.
}
\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}

\STATE PASS

\end{algorithmic}
\end{minipage}}

THE FAILURE PROCEDURE:

\begin{enumerate}[label*=\arabic*.]

  \item Let $P' := P$. This is so we do not modify the original
        $P$ during the procedure, as we will reference $P$.  

  \item Remove the last prime from $P'$.

  \item \label{fail_loop}
        Consider all $Q$-composed OPN's with $d$ prime divisors
such
        that $Q$ is a lexicographical predecessor of $P$. Denote
        this set of OPN's as $A$.(Since the algorithm works in
        lexicographical order, the algorithm has determined $A$
        for us) 

  \item If there does not exists an $a \in A$ such that $a$ is
    $P'$-initiated, go to step 2.

  \item Set $T(P') := True$. This value is false by default.

  \item Truncate elements from $P'$ until $T(P')$ is false.
        Clearly at least one element must be truncated.
        Afterwards, set $P := P'$. Terminate the algorithm.
\end{enumerate}

THE BACKUP PROCEDURE: Similar to the failure procedure but with
less steps and deletions.

\begin{enumerate}[label*=\arabic*.]

  \item Let $P' := P$. This is so we do not modify the original
        $P$ during the procedure, as we will reference $P$.  

  \item Remove the last prime from $P'$.

  \item \label{fail_loop}
        Consider all $Q$-composed OPN's with $d$ prime divisors
such
        that $Q$ is a lexicographical predecessor of $P$. Denote
        this set of OPN's as $A$.(Since the algorithm works in
        lexicographical order, the algorithm has determined $A$
        for us)

  \begin{enumerate}[label*=\arabic*.]

    \item If there exists an $a \in A$ such that $a$ is
    $P'$-initiated, then set $P := P'$. Now, terminate.

    \item If there does not exist such an $a$, Go to step 2
%{\ref{fail_loop}}

  \end{enumerate}

\end{enumerate}


%Todo : Start writing up algorithm in notebook.
\begin{proof}
We will use induction to prove this theorem, but we must first
find some sequence to induct on.

We define the set of sequences of increasing odd prime $\mathcal{P}_d$.
Let $P$ be an increasing sequence of $d$ primes. Then $P \in
\mathcal{P}_d$ if there exists a $P$-initiated OPN with $d$
divisors. Note that $\mathcal{P}_d$ is finite as the number of OPN's
with $d$ divisors is finite\cite{dickson}. Now consider the
lexicographical order of $\mathcal{P}_d$. As this set is finite,
the lexicographical order is a total order, and thus each element
of $\mathcal{P}$ has a unique predecessor and a unique successor,
unless it is the maximum or minimum element of $\mathcal{P}$.

It is noteworthy that the algorithm works in lexicographical
order, i.e., whenever $P$ is modified in the algorithm, the result
is a sequence of primes that is lexicograpically greater than $P$.

Let $M$ be the least element of $\mathcal{P}_d$. Our base case
for induction is: \textit{The algorithm collects all OPN's with
prime divisors $M$}. However, all we need to show is that our algorithm
reaches step 4, where the exponent algorithm is used.

TODO : base case

Now suppose that $P, Q \in \mathcal{P}$ such that $P$ is the
lexicographical predecessor of $Q$ in $\mathcal{P}$. Our inductive
step is: \textit{If the algorithm collects all OPN's with prime
divisors composing $P$, then the algorithm collects all OPN's with
prime divisors composing $Q$}.

We want to consider two cases. One case is where $P$ and $Q$ share
all primes except the last primes. The other case is when there
exists the nonnegative integer $i < d - 1$ such that $p_i <
q_i$ (\textit{where $p_i, q_i$ are the ith elements in the
sequences $P$, $Q$ respectivly}).

If $P$ and $Q$ share all but the last prime divisor, it is easy to
show that $max(Q)$ is the sequential prime after $max(P)$ using
Theorem {\ref{Continuity}}. The algorithm will thus immediently
find all $Q$-initiated OPN's with $d$ divisors.

Now suppose that $P$ and $Q$ share only $c < d - 1$ sequential 
primes, i.e., $P = \{ p_0, p_1, ..., p_{c - 1}, p_c, ..., p_{d-1}\}$
and $Q = \{p_0, p_1, ..., p_{c - 1}, q_c, ..., q_{d - 1}\}$. We
require that $p_c < q_c$, but there are requirements of $p_k$
and $q_k$ for $c + 1 \leq k \leq d - 1$. When the algorithm
reaches the step where $P := P$, we want to show that the
algorithm will transform $P$ to $Q$. 

Note that, after step $5$, the algorithm replaces $p_{d-1}$ with
its sucessor $p'_{d - 1}$. Here the algorithm fail at step 3 or
the algorithm will fail at step 7. When the failure procedure acts
on $P$, exactly one prime will be removed. In fact, this will
happen until $P := \{p_0, p_1, ..., p_{c-1}\}$. 

If the next prime after $p_c$ is $q_c$, then the algorithm will
append $q_c$, setting $P := P + q_c$. 

If the next prime after $p_c$ is not $q_c$, then $p_c \leq
Cap_d(P)$ by Theorem {\ref{cap}}. Also, $q \leq
nextprime(Cap_d(P)) $ by Theorem $4.5$. As the algorithm does not
stop checking primes until $p_c \geq nextprime(Cap_d(P))$, we have
that the algorithm will find $q_c$. 

Thus we will have that $P = \{p_0, p_1, ..., p_{c-1}, q_c\}$.

Now we need to show that the algorithm collects all $Q$-initiated
OPN's with $d$ divisors, starting with the $P$ we have achieved
above.

For each $q_i$ such that $c < i < d - 1$, we have that $q_i \leq
nextprime(Cap_d(Q_i))$, where $Q_i = \{p_0, p_1, ..., p_{c-1},
q_c, ..., q_{i - 1}\}$. This is the combination of Theorem
{\ref{cap}} and the fact that there is no sequence of $d$ primes 
$R$ such that $P < R < Q$ and there exists some $R$-initiated
OPN. As the algorithm will not stop checking primes until this
point, we have that the algorithm will add $q_i$ to $Q_i$ for any
$c < i < d - 1$. Thus the algorithm will find all $Q$-initiated
OPN's with $d$ divisors, completing the inductive step.
\end{proof}

\end{document}
