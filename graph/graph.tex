\documentclass[../paper.tex]{subfiles}


\begin{document}

%TODO: Mention that p_1, p_2, ..., p_d are always listed in increasing 
% order unless said not to be.
\section{The Main Algorithm}

\subsection{The Primitive Abundant Tree Structure}

We want to construct a useful structure that relates the primitive
abundant odd prime factors. 

Let $\mathbf{P}$ be a set of nodes such that each $n \in 
\mathbf{P}$ is defined as a pair including a positive integer 
and a sequence of primes. $n$ can take form 
$(p_3, \{p_0, p_1, p_2\})$ for primes $p_0,..., p_3$. 
$n$ can also be in the form $(1, \{\})$. Let $V$ be a set of 
edges between the nodes.

Finally, we define an acyclic connected graph $G_d(\mathbf{P},V)$ 
for some positive integer $d \geq 3$ where $G_d$ satisfies the 
following rules: 

\begin{enumerate}

\item $(1, \{\}) \in \mathbf{P}$. Denote this node $n_0$ for the next 
      statement.

\item If $p_1^{m_1}p_2^{m_2}...p_d^{m_d}$ is an primitive abundant 
      odd for positive integers $\{m_1, m_2, ..., m_d\}$, then
			the following are true: 

      i. $ (p_1, \{\}), (p_2, \{p_1\}), (p_3, \{p_2, p_1\}), ..., 
        (p_d, \{p_1, p_2, p_3, ..., p_{d-1}\}) \in \mathbf{P} $
			Denote these nodes $n_1, n_2, ..., n_d$ for simplicity in the 
			next statement.

      ii. $ (n_0, n_1), (n_1, n_2), (n_2, n_3), ..., (n_{d-1}, n_{d}) 
      \in V $

\end{enumerate}

Note that this graph contains a finite number of nodes since 
there are a finite number of primitive odd abundant numbers with
d divisors. 

When a diagram is drawn, the nodes are represented by the integer 
value they hold, and the sequence of primes before it can be deduced
from the edges in the graph. See the diagram of $G_3$ and $G_4$
below.

\subsection{Modification for the Algorithm}

We need to associate two statements with each node for the 
algorithm.

We define the statement $E_{(d,P)}$ for some sequrnce of primes P such 
that $E_{(d,P)} = $ "There exists a node $n \in G_d$ such that the
sequence 
of primes $P$ is associated with $n$". In other words this state that 
there exists some primitive abundant with $d$ divisors whose prime
factors are $P$.

We also define the 'exhausted' statement $X_{(d,P)}$ for some
sequence of 
primes $P = \{p_1, p_2, ..., p_i\}$   by $X_{(d,P)} = $ "all primes 
$q_{i+1}, q_{i+2}, ..., q_d$ have been found such that $p_1,p_2, 
..., p_i, q_{i+1}, q_{i+2}, ...q_d$ are all the prime factors to some
primitive abundant odd". This statement is specific to the algorithm 
and when a new node is created in the algorithm this will be included
as a third paramater that will be false by default. 


\subsection{The Algorithm}
\textbf{Algorithm} 

We want to determine $G_d$ with an algorithm, and use this
algorithm to find all odd primitive abundant numbers with $d$
divisors.  
which will eventually allow us to determine the primitive abundant 
odds with $d$ divisors.

Let $n \in \mathbf{P}$.
%
We define $n.P()$ will retrieve the prime associated with n, as
well as the sequence of primes associated with n, returning them as a 
sequence, from least to greatest prime.

\noindent
Now we define a few more advanced functions in the algorithm 
notation.


Let $G = (\mathbf{P}, V)$, and
let $n \in \mathbf{P}$ such that n has no child nodes. 
%Todo: Define a child node
%
We define $delete(n, G)$ in the following way: TODO. 

\begin {algorithmic}
\STATE TODO: Rewrite this algorithm from code, make a new flow
chart.

\end {algorithmic}

{\setlength{\parindent}{0cm}

\textbf{Algorithm: ExtractPrimitiveAbundantOdds}

\textbf{INPUT:} d, desired divisors.

\textbf{OUTPUT:} All Primitive Abundant Odds with d divisors.

}

\begin{algorithmic}
\STATE TODO: Change this to Sequences if possible.
\STATE $\mathbf{P} := \{(1, \{\}, FALSE)\}$
\STATE $V := \{\}$
\STATE $G_d := (\mathbf{P},V)$
% |P| = i
% NOTE: a LOT of graph and algorithm notation is borrowed from
%the book INTRODUCTION TO ALGORITHMS, THIRD EDITON (Cormen)(2011)
%WE NEED TO CITE OUR SOURCE, so people will know where to look to
%understand the notation here.
\WHILE {$(1, \{\}, FALSE) \in \mathbf(P)$}
	\STATE $newnode = Insert(p,\mathbf{P})$ 
	%TODO define insert - insert element into list
	\STATE $P = newnode.P()$
	\STATE


	\IF {$b(p_1 p_2 p_3 ... p_i) \geq 2$}	
		\IF {$i = d$}
			\STATE $success(newnode)$
		\ELSE
			%TODO: Define deficient prime == ALSO DETAILS ABOUT EDGES@!!!1!!!!!
			% REALLY IMPORTANT THAT YOU TALK ABOUT NOT CHANGING CONNECTIONS
			% IMPORTANT THAT IF (11, ...) -> (17, ...) AND 17
			% IS CHANGED TO 19 THAT THE CONNECTION REMAINS!!
			% (11, ...) -> (19, ...);
			\STATE $deficientNode(newnode)$
			\STATE $P \leftarrow newnode.P()$
		\ENDIF
	\ENDIF
	\IF{$b_{\infty}(p_0, p_2, ..., p_i) > 2$}
		\IF {$i == d$}
			\STATE $fail(newnode)$
		\ENDIF
	\ELSIF {$i == d$}
		%TODO: define this function.
		\IF {$expFind(P)$}
			\STATE $success(newnode)$
		\ELSE
      \STATE Due to some new modifications, this section needs a
fix. We need to check certain primes. More details to come. 
			\STATE $fail(newnode)$
		\ENDIF
	\ENDIF

\ENDWHILE
% What this does is checks if the element FAlSE in the initial
% node that includes 1 as it's 'prime' has not changed its 
% boolean value 'exhausted' to True.
  %\WHILE {$(1, \{\}, FALSE) \in \mathbf{P}$ do}
	%	\STATE test
	%
%
\end{algorithmic}

\textbf{END}



%Todo : Start writing up algorithm in notebook.
\begin{proof}
Will use Continuity of Primitive Abundant Numbers and Prine
Divisibility of Abundant Numbers.

We will also do a proof by induction, on the sequences of primes.
We will lexicographically order the sequences of primes to do
this.

Suppose that $P$ and $Q$ are sequences of $d$ primes such that $P$
and $Q$ compose the prime factorization of two odd primitive
abundant numbers. Suppose that $Q$ is the greatest predecessor of
$P$ with the primitive abundant property. We want to show that if
the algorithm collects $P$, then it must collect $Q$. 

For the base case: We need to use Theorem {\ref{Primechops}} to
construct the smallest sequence and show that the algorithm
collects it. Would be nice to show that the smallest sequence
starts with a $3$

To prove this we have two cases: $P$ and $Q$ share all but the
last prime factor or $P$ and $Q$ have less elements in common
prime factor.

In the case where $P$ and $Q$ share all but the prime factor, we
will argue the fact that $P$ is the immedient predecessor of $Q$,
i.e. the last element of $Q$ is the next prime after the last
element of $P$. This is beacause of Theorem {\ref{Continuity}}. In
this case, $Q$ will definately be the next prime sequence checked
and therefore the algorithm will discover $Q$.

In the case where $P$ and $Q$ have at least two elements not in
common, we want to use Theorem {\ref{Divisibility}} and show that
the divisors of $P$ are fixed at a certain size.

\end{proof}

\end{document}
