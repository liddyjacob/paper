\documentclass[../paper.tex]{subfiles}

\begin{document}

\section{Exponent Theorems and Algorithm}

In this section we will understand some of the conditions that
exponents of primative abundant odd numbers must follow. In order
to do this we first must define some functions and prove theorems 
that will allow us to determine some meaningful information about
exponents of primative abundant odds.

We Want to define $G_{\Delta_{+}}(P,E)$ as a function which lists
the indicies $i$ of prime/exponent pairs in sequences P and E
in order of least $\Delta_{+}(p_i, e_i)$ to greatest.
\\

To demonstrate the above function, we calculate 
$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\})$.

First we calculate each of $\Delta_{+}(3,1)$, $\Delta_{+}(5,2)$, 
and $\Delta_{+}(11,1)$. We find that 
$\Delta_{+}(3,1) = \frac{13}{12}$,
$\Delta_{+}(5,2) = \frac{156}{155}$, and
$\Delta_{+}(11,1)= \frac{133}{132}$.
Thus the order of $\Delta_{+}$ is as follows:

$$ \Delta_{+}(3,1) > \Delta_{+}(11,1) > \Delta_{+}(5,2)$$

Giving the primes indicies based off its order in the prime
factorization of $3^1 5^2 11^1$ starting at zero, we obtain that

$$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\}) = \{1,2,0\}$$
\\

We also need some theorems on determining when numbers are 
primative abundants and not just abundant.

No divisor of a primative abundant number is abundant, so 
we have that decreasing any exponent of any prime factor will
produce a deficient number. Thus we formally prove the below
theorem.

\begin{theorem}\label{del_minus_thm}
Suppose a number $n = p_1^{m_1} p_2^{m_2} ... p_d^{m_d}$ is 
abundant. Then $n$ is primative if and only if the 
following property holds:

Given any index of any prime/exponent pair $i$, we have that
$$b(n) \Delta_{-}(p_i, e_i) = b(p_1^{m_1} p_2^{m_2} ...  
p_i^{m_i - 1} p_{i+1}^{m_{i+1}}... p_d^{m_d}) < 2$$
\end{theorem}

\begin{proof}
	First suppose that $n$ is a primative abundant. Then any divisor of $n$
is deficient. Since decreasing any exponent in the prime 
factorization of $n$ produces a divisor of $n$, and since any
divisor of $n$ is deficient by nature of $n$ being primative,
we have that 
$$b(p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d{m_d}) < 2$$
Thus the property holds.

	Suppose the property holds, and that $n$ is abundant. Suppose $d$
is a proper divisor of $n$. Since $d$ is a proper divisor, it must
be a divisor smaller than $n$. Thus at least one of its prime factors
will have multiplicity less than $n$. This implies that $d$ is a 
divisor of
$n' = p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d{m_d})$ 
for some $i$ such that $1 \leq i \leq d$. Hence $b(d) \leq b(n')$.
Since our property holds, we have that $b(n') < 2$. Since $d$ is
a divisor of $n'$, we have that $b(d) \leq b(n') < 2$. Thus we
have that all proper divisors of $n$ are deficient, and hence $n$ is 
a primative abundant number.
\end{proof}

We define the order of a divisor d (with respect to some multiple
$n$) as the difference in the sum of the exponents between a
divisor and some multiple of that divisor. Suppose $n = p_0^{m_0}
p_1^{m_1} ... p_{d-1}^{m_{d-1}}$ is an integer and $d = p_0^{\ell_0}
p_1^{\ell_1} ... p_{d-1}^{\ell_{d-1}}$. As $d$ is a divisor of
$n$, we have that $m_i \leq \ell_i$ for each $i$. The
\textit{order of $d$ with respect to $n$} is defined as $\sum {m_i
- \ell_i}$. If $d$ is not a divisor of $n$, then the order of $d$
is undefined and meaningless. If the prime factorization of $d$ is
missing some prime factor, then the exponent of that prime factor
is zero.


Suppose $P = \{p_0, p_1, ...,p_{d-1}\}$ are primes and 
$E = \{e_0, e_1, ..., e_{d-1} \}$ are positve integers.
We define $primative(P,E)$ as a statement that yeilds true
if $p_0^{e_0} p_1^{e_1} ... p_{d-1}^{e_{d-1}}$ is a primative
abundant number, and false otherwise.
%TODO: ADD theorem? what does this mean?

%TODO: Talk about subtraction order divisors and immedient
%divisors.



\begin{theorem} 
Let $P$ be a sequence of $d$ odd primes. If $b_{\infty}(P) > 2$, then the 
following algorithm will extract all primative
abundant odd numbers whose prime divisors compose $P$.
\end{theorem}
% The algorithm:
%
% * Set initial exponents to 1 
%
% * Check if abundant. If so check if primative
%   * If not primative, no abundant odds 
%		* If primative, this is 
%
% * If b(p1^e1 p2^e2 ... pd^ed) >= 2
%		* If primative this is an option : return true
%		* If not return false
%
%	* Check to see if any exponent increases will cause abundance
%    If any do cause abundance, check if primative.
%    Always start with the exponents of highest 'influence'
%		 then move on to lower 'influence' exponents. influence
%    is measured by which exponents increase b(n) the most
%    Del_pos is exactly the measure of this.
%
%	* Once the first exponent which does not cause abundance is found
%    we want to check which exponents can be raised to 'infinity'
%    to eventually produce an abundant number. We raise the exponents
%    NEED TO TALK ABOUT ORDER OF INFLUENCE HERE. IN THE ALGORITHM
%    WE ASSUME INFINITE INFLUENCE IS DIRECTLY RELATED TO FINITE
%    SINGLE EXPONENT INFLUENCE? IS THIS TRUE? I DONT KNOW.
%				*Infinite influence: Take a prime-exp pair p^e -> p^infinity
%				*Finite influence  : Take a prime-exp pair p^e -> p^(e+1)
%       Are they related?
% ^ * Mixed b: Raise exponents of low influence pairs to see if they
%     mixed with others will eventually go on to infinity
% ^ * If so raise 

% THIS is going to be UGLY.
% NEW THEorem added - may be important

\textit{In the below algorithm, the sequence of primes P is indexed 
starting at 0, not 1. In other words, $P = \{p_0, p_1, ..., p_{d-1}\}$}



{\setlength{\parindent}{0cm}

\textbf{The main algorithm}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$.

\textbf{OUTPUT:} All primative abundant odds whose prime factors
compose $P$

}


\begin{algorithmic}
%E represents exponents

\STATE $E := \{e_0 = 1,e_1 = 1,...,e_n = 1\}$
\STATE $A := \{ \}$ %primative-abunant odds

\STATE $expAbundant(P, E, A)$

\RETURN $A$

\end{algorithmic}

{\setlength{\parindent}{0cm}

\textbf{Algorithm: expAbundant}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, the exponents to those 
primes $E$, and the primative abundants found so far, $A$.

\textbf{OUTPUT:} True or false, depending on if the algorithm has found any
primative abundant numbers.

}

\begin{algorithmic}
\IF {$b(P, E) \geq 2$}
	\IF {$primative(P, E)$}
		\STATE $A := A \& (P,E)$
		\RETURN TRUE
	\ENDIF
	\RETURN FALSE
\ENDIF

\RETURN $orderDelPos(P,E,A,|P| - 1)$

\end{algorithmic}

{\setlength{\parindent}{0cm}

\textbf{Algorithm: orderDelPos}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, exponents $E = \{ m_0, m_1,
...\}$, the set of primative abundant numbers found $A$,
and the starting index $s$ of the $G_{\Delta_{+}}(P,E)$.

\textbf{OUTPUT:} All primative abundant odds whose prime factors
compose $P$

}


\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
%Index of delta_pos in order of 
%of ascending order:
% The last element as the most influence
% G is for generate: Make this function
\STATE $I_{\Delta_{+}} := G_{ \Delta_{+}}(P,E)$

\STATE $i_{\Delta_{+}} := s$ %Index in I_delta

\STATE $i_p := 0$ %Prime index

\WHILE {$i_{\Delta_{+}} \geq 0$}
	\STATE $i_p := I_{\Delta_{+}}[ i_{\Delta_{+}} ]$

	%\STATE $\Delta_{+} := \Delta_{+}(P_{i+p})$

	\IF {$b(P,E) \Delta_{+}(P[i_p], E[i_p]) \geq 2$}
		\STATE \COMMENT{$E_{new}$ is the new exponents raising the exponent that
		allows the number to be abundant}
		\STATE $E_{new} := E$
		\STATE $E_{new}[ i_p ] := E_{new}[ i_p ] + 1 $
		
		\IF {$primative(P, E_{new})$}
			\STATE $A := A\&(P,E)$
			\STATE $e_{found} := $ TRUE
		\ENDIF

		\STATE $i_{\Delta_{+}} := i_{\Delta_{+}} - 1$  
	
	\ELSE
		\STATE break;
	\ENDIF
\ENDWHILE


\IF {$i_{\Delta_+} \geq 0$}
	\STATE \COMMENT{Not all indexed exponents
	were able to make an abundant when raised one power}
	\IF {$expIncAlg(P, E, A, I_{\Delta_{+}}, i_{\Delta_{+}})$}
		\STATE $e_{found} := $ TRUE
	\ENDIF
\ENDIF

\end{algorithmic}
expIncAlg: Parameters - P, E, A, Indexed Delt+'s in order, current index
in last parameter

\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
\STATE $i_{\Delta_{+}}  := s$

\WHILE {$i_{\Delta_{+}} \geq 0$}
	\STATE \COMMENT{ exponent indicies that,when increased by 1, 
do not change the fact that n is deficient}
	\STATE $I_{b < 2} := \{I_{\Delta_{+}}[0], I_{\Delta_{+}}[1], 
	                       ..., I_{\Delta_{+}}[i_{\Delta_{+}}],\}$

	\IF {$mb(P, E, I) \geq 2$}
		\STATE \COMMENT{When other exponents that would not normally
cause n to be abundant by themselves are increased, this
exponent combined with other exponents in the stated situation
will eventually allow n to be an abundant number. Try increasing
it.}
		\STATE $E_{new} := E$
		
		%Exponent index:
		\STATE $e_i := I_{\Delta_{+}}[i_{\Delta_{+}}]$
		\STATE $E_{new}[e_i] := E_{new}[e_i] + 1$

		% TODO: here we start at i_delt+. How can we assume this?
		% Is it okay to start from the beginning to avoid this assumption?

    % TOO HARD TO PROVE, we shold not assume

		% I think we can assume because if one exponet prime sequence changes,
		% then I shifts over none or by one. If none, we are double
		% checking the prime-exp-pair
		% otherwise should we move back one or is this fine?

		%                                           _ | _
		%                                            \|/
    %                                             .
		\IF {$OrderDelPos(P, E_{new}, A |P| - 1)$}%, i_{\Delta_{+}})$}
			\STATE $e_{found} :=$ TRUE
		\ENDIF

	\STATE $i_{\Delta_{+}} :=  i_{\Delta_{+}} - 1$

	\ENDIF 

\ENDWHILE

\end{algorithmic}


TODO: DISCUSSION ON HOW THIS ALGORITHM WORKS?

\begin{proof}
  In order to prove that this theorem we need to show that if $n$
is primative with prime factors composing $P$ then $n$ 
will be gathered by this algorithm. Suppose that $n$ has the
prime factorization $n = p_0^{m_0} p_1^{m_1} ...
p_{d-1}^{m_{d-1}}$, where the prime factors $P$ follow the
conditions $b_1(P) < 2$ and $b_{\infty}(P) \geq 2$. Also note 
that $n$ has the property described in Theorem
{\ref{del_minus_thm}}, as $n$ is a primative abundant number. 
We want to show that the algorithm will gather the exponents 
$m_0, m_1, ..., m_{d-1}$. 

  First assume that all exponents of $n$ are one. Then this
algorithm will check if $n$ is primative, which it is, and
terminate. Thus this algorithm terminates and finds the only
possible $n$ with prime divisors composing P. 

%The theorem can be stated as Let $n$ be a compsite number whose
%prime divisors compose n. if $n$ is primative abundant, then this algorithm
%will find $n$. Therefore, we can attempt the contradition or
%contra positive. The contradiction would be this algorithm will
%not find $n$ for some primative abundant $n$.

  We now assume that at least one exponent $m_t$ is greater than
two, hence $b_1(P) < 2$. Suppose, to the contrary, that $n$ is not
obtained with the above algorithm, where $n$ is primative(When
this algorithm runs, we will have that $(P,E) \notin A$). Note that 
$n' = p_0^{m_0}...p_t^{m_t - 1}...p_{d-1}^{m_{d-1}}$ is deficient 
because $n$ is primative and therefore all of the divisors of $n$
are deficient. 

  The algorithm may pass this divisor of $n$, or perhaps it may
not. We proceed by cases:

\textbf{Case 1:}
  If the algorithm passes some deficient divisor of the above form, 
i.e. $E' = \{m_0, m_1, ..., m_t - 1, ..., m_d \}$ occurrs in this 
algorithm, we want to determine where it will occurr such that 
$m_t - 1$ is not increased by the algorithm. $E'$ can occurr for
the first time at one of three possible places: In $expAbundant$, 
$orderDelPos$ or $ExpIncAlg$.

\textbf{Case 1.1:}  
  Suppose that the algorithm passed $E'$ in expAbundant. If this
is the case, then all of the exponents in the prime factorization
of $n'$ are $1$. This is because the algorithm only passes
$expAbundant$ at the very beginning, and that is when all elements
in $E$ are one. As this is a deficient number, the $expAbundant$
will return the value of $orderDelPos(P,E,A,|P| - 1)$.


  Recall that $G_{Delta_+}$ is the sequence of $\Delta_+(p_j e_j)$
where $p_j = P[j]$ and $e_j = E[j]$ ordered from least to greatest.
The loop will check to see what exponent increases will lead to
abundant numbers, and by checking the end of $G\Delta_+(p_j, e_j)$
first, the algorithm will check the exponents of greatest
influence first, i.e. the exponent which, if increased, will
increase $b(P,E)$ the most. The loop will terminate once it
has found all primes whose exponent increased by one makes an
abundant number. We know that $n = p_0^1 p_2^1 ... p_t^2...
p_{d-1}^1$ as $n' = p_0^1 ... p_t^1 ... p_{d-1}^1$.
 Clearly, rasing the exponent of $p_t$ in $n'$ by one will
produce an abundant number as $n = p_0^{1} ... p_t^{2} ...
p_{d-1}^1$ is primative abundant. Thus the loop will check if $n$
is primative, which it is, and therefore $(P,E) \in A$, which we
assumed was false.

\textbf{Case 1.2:}
  Suppose that the algorithm creates $E'$ for the first time in
$orderDelPos$. The only place in which any exponent sequence is created
or updated is where $E_{new}$ is created here:
\begin{algorithmic}
 
	\IF {$b(P,E) \Delta_{+}(P[i_p], E[i_p]) \geq 2$}
		\STATE $E_{new} := E$
		\STATE $E_{new}[ i_p ] := E_{new}[ i_p ] + 1 $
		
		\IF {$primative(P, E_{new})$}
			\STATE $A := A\&(P,E)$
			\STATE $e_{found} := $ TRUE
		\ENDIF 

  \ENDIF
\end{algorithmic}

  Thus we suppose that $E'$ is obtained here as $E_{new} = E'$.
However, the condition of the if-statement above implies that
$E_{new} = E'$ is such that $b(P,E_{new}) = b(P,E') > 2$, which
implies that $n'$ is abundant. This contradicts the fact that $n'$
is a deficient as it is a divisor of a primative abundant number.
deficient. Thus $E'$ can't be obtained in OrderDelPos.

\textbf{Case 1.3:}
  Suppose that the algorithm creates $E'$ for the first time in
$expIncAlg$. $E'$ would, again, be concieved as $E' = E_{new}$. 

\begin{algorithmic}
\WHILE {$i_{\Delta_{+}} \geq 0$}
  \STATE $I_{b < 2} := \{I_{\Delta_{+}}[0], I_{\Delta_{+}}[1], 
	                       ..., I_{\Delta_{+}}[i_{\Delta_{+}}],\}$

	\IF {$mb(P, E, I_{b < 2}) \geq 2$}

  	\STATE $E_{new} := E$
		
		\STATE $e_i := I_{\Delta_{+}}[i_{\Delta_{+}}]$
		\STATE $E_{new}[e_i] := E_{new}[e_i] + 1$

  	\IF {$OrderDelPos(P, E_{new}, A, |P| - 1)$}
			\STATE $e_{found} :=$ TRUE
		\ENDIF

	\STATE $i_{\Delta_{+}} :=  i_{\Delta_{+}} - 1$

	\ENDIF 

\ENDWHILE

\end{algorithmic}

If this is the case, $E'$ will be run through $OrderDelPos(P, E',
A, |P| - 1)$. Here we will have that the exponents of $E'$ that
will make $E'$ abundant will be raised, and since raising $m_t -1$
will make an abundant number, we have that $n$ will be discovered
in the algorithm, a desired contradiction.


\textbf{Case 2:}
  If the algorithm does not pass any of the deficient numbers in
the form $n' = p_0^{m_0}...p_{t}^{m_t - 1}...p_{d-1}^{m_{d-1}}$ ,
then  we want to show that the algorithm will not find any of the
divisors. If we can show this from the given information, it will
contradict the fact that the algorithm has already found $ p_0 p_1
p_2 ... p_{d-1}$.

In order to prove that the algorithm will find none of the
divisors of $n$, we will use induction to show that if the
algorithm does not find any divisors of order $v$, then the
algorithm will not find any divisors of order $v + 1$. The base
case is true since the algorithm does not find any divisors of
order 0(i.e. $n$) and the algorithm does not find any divisors of
order 1(The immedient divisors $n'= ...$).

Suppose, to the contrary, that the algorithm does not find any
divisors of order $v$ yet does find at least one divisor of order
$v+1$. Call the found divisor $n^{(v+1)'}  = p_0^{m_0} p_1^{m_1} ...
p_{i_1}^{m_{i_1} - l_1} ... p_{i_2}^{m_{i_2} - l_2} ... ...
p_{i_k}^{m_{i_K} - l_k} ... p_{d-1}^{m_{d-1}}$, where $\sum_{1 \leq j
\leq k} l_j = v + 1$.

Note that $n^{(v+1)'}$ can be found in one of three places. Call 
the exponent sequece of $n^{(v+1)'}$ by $E_{v+1}$ 
We will break this up into cases:

\textbf{Case 2.1:} 
  Suppose that the algorithm creates $E_{v+1}$ for the first time in
$expAbundant$. Then $n^{(v+1)} = p_0^1 p_1^1 ... p_{d-1}^1$. As all
divisors of order $v$ are not found in the algorithm, the
algorithm   

we have that
only exponents i can be raised such that $p_i | n$ yet $p_i^2
\nmid n$. 

  As the algorithm moves into $orderDelPos$, we have that a few
exponent increases may lead to an abundant number, but these will
not lead to $n$, unless $v = 0$. In other words, if $v= 0$, then
the algorithm will find a divisor of order $v = 0$, which is $n$.
This can't be the case, as we assumed that the algorithm does not
find any divisor of order $v = 0$.

  Thus we assume that $v \geq 1$. If that is the case, we will
have some exponents that, when raised multiple times, will create
an abundant number. Thus the algorithm will move on to
$expIncAlg(P,E_{v+1},A, I_{\Delta_+}, s)$.

  We write $n^{(v + 1)}$ in a form such that $n^{(v + 1)} =
p_0^{m_0 - v_0} p_1 ^{m_1 - v_1} ... p_{d-1}^{m_{d-1} - v_{d-1}}$,
where $\sum v_i = v$. Now construct a set $I_{v+1}$ of indicies 
$i$ such that if $v_i \neq 0$ then $v_i \in I_{v+1}$. Notice that
raising exponents with these indicies alone will not produce an 
abundant number, Thus these exponents will all appear in $I_{b >
2}$. Consider the element of $I_{v+1}$ that is furthest in the
sequence $I_{b > 2}$. Call this element $i_{max}$. Note here that
$mb(P,E,I_{v+1}) > 2$ as rasing exponents with indicies in 
$I_{v+1}$ will eventually produce an abundant number. Notice that the
algorithm will increase all exponents that come after $i_{max}$ in
$I_{b+1}$,
as we have that $I_{v + 1} \subseteq I_{b > 2} = 
                          \{I_{\Delta_{+}}[0], I_{\Delta_{+}}[1], 
	                        ..., I_{\Delta_{+}}[i_{max}],...,
                          I_{\Delta_{+}}[i_{\Delta_+}]\}$.

as the function $mb(P,E,I)$ has the property that, if $X \subseteq
Y$, then $mb(P,E,X) < mb (P,E,Y)$. This is because $b_{\infty}(p)
b(p,e)$. Therefore when the algorithm is such that
$i_{\Delta_{+}} = i_{max}$, we will have that $m_{i_{max}}$ will
be increased, and we will have that the new resulting number is a
divisor of $n$, and is a divisor of order $v$, which contradicts
the the fact that no divisors of order $v$ are discovered in the
algorithm.  

\textbf{Case 2.2:}
Impossible...
\textbf{Case 2.3:}
Similar to Case 2.1?
If $n^{(v+1)}$ is discovered here , then it will be passed into
$orderDelPos$, which will bring us back to case 2.1/

Hence, we have that no divisors of $n$ can be discovered in the
algorithm, by some convoluted induction scheme. However, this
contradicts the fact that $p_0 p_1 p_2 ... p_{d-1}$ is a divisor
of $n$ and is discovered in the algorithm, thus the original
assumption is false.

In both case, the assumptions were false, thus the assumption that
$n$ was not discovered in the algorithm is false, and therefore
$n$ IS discovered in the algorithm, proving the theorem.

\end{proof}

\subsection{Properties of the Exponent Algorithm}

\begin{theorem}[Property 1]

\end{theorem}

\begin{conj}[Continuity of Primative Abundant Numbers]:
Let $q \leq r$ be primes. Suppose that $p_0, p_1, p_2, ..., 
p_{l-2}, q$ are the first l divisors of some primative abundant
odd with $d$ prime divisors. Suppose $p_0, p_1, ..., p_{l-2},r$ 
are also the first $l$ divisors of some primative abundant odd
with $d$ prime divisors. Then, given any prime $s$ such that $q \leq s 
\leq r$, we have that $p_0, p_1,..., p_{l-2}, s$ are the first $l$
divisors of some primative abundant odd with $d$ divisors.
\end{conj}

\begin{proof}
  We will use induction to prove this theorem. The base case is
the following statement:

  \textit{Suppose that $p_0, p_1, p_2, ..., 
p_{d-2}, q$ are the divisors of some primative abundant
odd with $d$ prime divisors. Suppose $p_0, p_1, ..., p_{d-2},r$ 
are also the divisors of some primative abundant odd
with $d$ prime divisors. Then, given any prime $s$ such that $q \leq s 
\leq r$, we have that $p_0, p_1,..., p_{d-2}, s$ are the 
divisors of some primative abundant odd with $d$ divisors.}

And our inductive step will be:

  \textit{Assume that the theorem is true for the last $k$
divisors. Prove that the theorem is true for that last $k + 1$
divisors.}

We start this proof with the base case. Note that since each sequence
of primes will produce a primative abundant number, we have that
the exponent algorithm will produce all possible combinations of
exponents that create abundant numbers for the prime sequences $Q = 
\{p_0, p_1, ..., p_{d-2}, q\}$ and $R = \{p_0, p_1, ..., p_{d-2},
r\}$. Also, notice that both Q and R will have the same initial
$G_{\Delta_+}$ values when used with the initial exponent sequence
in the exponent algorithm. And as the primes are in increasing
order, the $G_{\Delta_+}$ values are going to be exactly the same
for Q and R, and in fact (giving q and r indicies of d-1) we have
that $G_{\Delta_+}(Q, \{1,1,1,...\}) = G_{\Delta_+}(R,
\{1,1,1,...\}) = \{(d-1), (d-2), ..., 1, 0\}$. Because of this,
the exponent algorithm will follow the same path for a while for
both $Q$ and $R$.


There are two occurances that will stop Q and R's algorithm from
running paralell:
\begin{enumerate}
  \item q's exponent is increased before r's expoent is.
  \item Q's algorithm produces a primative abundant number and R's
algorithm has not yet.
\end{enumerate}

Possibilities:
  * Q and R produce a primative abundant number before diverging.
  * Q's algorithm produces an abundant number and R has not yet produced an
abundbat number, they have not diverged before this.
  * Q and R has not produced an abundant number, and are about to
diverge. with different exponent increases

Is this exhaustive??

Is the last * possible? probablty. If so will it be hard to
discuss and prove? Yes. Talk about s's index appearing inbetween
q and r.


\end{proof}


%todo TODO todo TODO fixme TODO:
% TALK ABOUT IMMEDIENT DIVISORS!!
% (exponents of prime factors minus one.)




%upp 
%Work backwards until exponents are all one? Show that $n$ will
% be found?
%Properties of this algorithm important?

%The issue with the below statement is it assumes the thing we are
%trying to prove, so contradiction will be used above instead.

%Thus, $n$ was either discovered in the 
%\textbf{if} $primative(P,E_{new})$ statement of OrderDelPos or
%expIncAlg. Suppose that $n$ was discovered in OrderDelPos

%% Old stuff where we assumed we did not have to change indicies
%would normally go here, but that makes the proof extemely
%difficult. It is probably commented out hiding at the bottom.


%We denote the first version of $I_{b>2}$ as $I_{max}$, i.e. the
%version that was first created when the while loop ran for the
%first time. We want to show that $t \in I_{max}$.

%If $t \notin I_{max}$ then we have that t was possibly increased
%in 

%of this loop if it was in a
%previous version of $I_{b>2}$, i.e. the 
% See notebook


% 
% Two MORE cases: t = i_{\Delta} or t != i_delta
% We need to show that if t = i_{\delta} then
% upon regeneration of G we will not move t.
% Note when m_t is increased it will
% have LESS influence on G and therefore 
% t will be moved up.
% that 



%
%We
%first show that $t \in I_{b > 2}$ 

% Either t in I or t notin I

%  Suppose that $t \notin I_{b > 2}$. Also,
%let $E''$ be the exponent sequence that was used to create $E_{new}$.
%Thus $E'' = \{m_0, m_1, ..., m_t - 1, ..., m_u - 1, ..., m_{d-1}\}$, 
%$E'' = \{m_0, m_1, ..., m_t - 2, ..., m_{d-1}\}$ or $E'' = \{ m_0,
%m_1, ..., m_u - 1, ..., m_t - 1, ... m_{d-1}\}$. 

%If $E'' = \{m_0, m_1, ..., m_t - 2, ..., m_{d-1}\}$, then the
%algorithm raised $m_t$ by one to create $E'$, and therefore 
%$\Delta_+(p_t, m_t - 2) = I_{del}[]$
%2 =

%i_(\Delta_+)$ which implies $t = i_{\Delta_+}$. 


%Then we have that $I_{\Delta_+} = G_{\Delta_+}(P, E'')$. 
%In order to achive a desired contradiction, We need to have that 
%$t \in I_{b > 2}$. If 


\end{document}
