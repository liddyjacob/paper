\documentclass[../paper.tex]{subfiles}

\begin{document}

\section{Exponent Theorems and Algorithm}

In this section we will understand some of the conditions that
exponents of primative abundant odd numbers must follow. In order
to do this we first must define some functions and prove theorems 
that will allow us to determine some meaningful information about
exponents of primative abundant odds.

We Want to define $G_{\Delta_{+}}(P,E)$ as a function which lists
the indicies $i$ of prime/exponent pairs in sequences P and E
in order of least $\Delta_{+}(p_i, e_i)$ to greatest.
\\

To demonstrate the above function, we calculate 
$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\})$.

First we calculate each of $\Delta_{+}(3,1)$, $\Delta_{+}(5,2)$, 
and $\Delta_{+}(11,1)$. We find that 
$\Delta_{+}(3,1) = \frac{13}{12}$,
$\Delta_{+}(5,2) = \frac{156}{155}$, and
$\Delta_{+}(11,1)= \frac{133}{132}$.
Thus the order of $\Delta_{+}$ is as follows:

$$ \Delta_{+}(3,1) > \Delta_{+}(11,1) > \Delta_{+}(5,2)$$

Giving the primes indicies based off its order in the prime
factorization of $3^1 5^2 11^1$ starting at zero, we obtain that

$$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\}) = \{1,2,0\}$$
\\

We also need some theorems on determining when numbers are 
primative abundants and not just abundant.

No divisor of a primative abundant number is abundant, so 
we have that decreasing any exponent of any prime factor will
produce a deficient number. Thus we formally prove the below
theorem.

\begin{theorem}\label{del_minus_thm}
Suppose a number $n = p_1^{m_1} p_2^{m_2} ... p_d^{m_d}$ is 
abundant. Then $n$ is primative if and only if the 
following property holds:

Given any index of any prime/exponent pair $i$, we have that
$$b(n) \Delta_{-}(p_i, e_i) = b(p_1^{m_1} p_2^{m_2} ...  
p_i^{m_i - 1} p_{i+1}^{m_{i+1}}... p_d^{m_d}) < 2$$
\end{theorem}

\begin{proof}
	First suppose that $n$ is a primative abundant. Then any divisor of $n$
is deficient. Since decreasing any exponent in the prime 
factorization of $n$ produces a divisor of $n$, and since any
divisor of $n$ is deficient by nature of $n$ being primative,
we have that 
$$b(p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d{m_d}) < 2$$
Thus the property holds.

	Suppose the property holds, and that $n$ is abundant. Suppose $d$
is a proper divisor of $n$. Since $d$ is a proper divisor, it must
be a divisor smaller than $n$. Thus at least one of its prime factors
will have multiplicity less than $n$. This implies that $d$ is a 
divisor of
$n' = p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d{m_d})$ 
for some $i$ such that $1 \leq i \leq d$. Hence $b(d) \leq b(n')$.
Since our property holds, we have that $b(n') < 2$. Since $d$ is
a divisor of $n'$, we have that $b(d) \leq b(n') < 2$. Thus we
have that all proper divisors of $n$ are deficient, and hence $n$ is 
a primative abundant number.
\end{proof}

Suppose $P = \{p_0, p_1, ...,p_{d-1}\}$ are primes and 
$E = \{e_0, e_1, ..., e_{d-1} \}$ are positve integers.
We define $primative(P,E)$ as a statement that yeilds true
if $p_0^{e_0} p_1^{e_1} ... p_{d-1}^{e_{d-1}}$ is a primative
abundant number, and false otherwise.
%TODO: ADD theorem? what does this mean?

\begin{theorem} 
Let $P$ be a set of $d$ odd primes. If $b_{\infty}(P) > 2$, then the 
following algorithm will extract all primative
abundant odd numbers whose prime divisors compose $P$.
\end{theorem}
% The algorithm:
%
% * Set initial exponents to 1 
%
% * Check if abundant. If so check if primative
%   * If not primative, no abundant odds 
%		* If primative, this is 
%
% * If b(p1^e1 p2^e2 ... pd^ed) >= 2
%		* If primative this is an option : return true
%		* If not return false
%
%	* Check to see if any exponent increases will cause abundance
%    If any do cause abundance, check if primative.
%    Always start with the exponents of highest 'influence'
%		 then move on to lower 'influence' exponents. influence
%    is measured by which exponents increase b(n) the most
%    Del_pos is exactly the measure of this.
%
%	* Once the first exponent which does not cause abundance is found
%    we want to check which exponents can be raised to 'infinity'
%    to eventually produce an abundant number. We raise the exponents
%    NEED TO TALK ABOUT ORDER OF INFLUENCE HERE. IN THE ALGORITHM
%    WE ASSUME INFINITE INFLUENCE IS DIRECTLY RELATED TO FINITE
%    SINGLE EXPONENT INFLUENCE? IS THIS TRUE? I DONT KNOW.
%				*Infinite influence: Take a prime-exp pair p^e -> p^infinity
%				*Finite influence  : Take a prime-exp pair p^e -> p^(e+1)
%       Are they related?
% ^ * Mixed b: Raise exponents of low influence pairs to see if they
%     mixed with others will eventually go on to infinity
% ^ * If so raise 

% THIS is going to be UGLY.
% NEW THEorem added - may be important

\textit{In the below algorithm, the set of primes P is indexed 
starting at 0, not 1. In other words, $P = \{p_0, p_1, ..., p_{d-1}\}$}



{\setlength{\parindent}{0cm}

\textbf{The main algorithm}

\textbf{INPUT:} The set of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$.

\textbf{OUTPUT:} All primative abundant odds whose prime factors
compose $P$

}


\begin{algorithmic}
%E represents exponents

\STATE $E := \{e_0 = 1,e_1 = 1,...,e_n = 1\}$
\STATE $A := \{ \}$ %primative-abunant odds

\STATE $expAbundant(P, E, A)$

\RETURN $A$

\end{algorithmic}

{\setlength{\parindent}{0cm}

\textbf{Algorithm: expAbundant}

\textbf{INPUT:} The set of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, the exponents to those 
primes $E$, and the primative abundants found so far, $A$.

\textbf{OUTPUT:} True or false, depending on if the algorithm has found any
primative abundant numbers.

}

\begin{algorithmic}
\IF {$b(P, E) \geq 2$}
	\IF {$primative(P, E)$}
		\STATE $A := A \& (P,E)$
		\RETURN TRUE
	\ENDIF
	\RETURN FALSE
\ENDIF

\RETURN $orderDelPos(P,E,A,|P| - 1)$

\end{algorithmic}

{\setlength{\parindent}{0cm}

\textbf{Algorithm: orderDelPos}

\textbf{INPUT:} The set of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, exponents $E = \{ m_0, m_1,
...\}$, the set of primative abundant numbers found $A$,
and the starting index $s$ of the $G_{\Delta_{+}}(P,E)$.

\textbf{OUTPUT:} All primative abundant odds whose prime factors
compose $P$

}


\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
%Index of delta_pos in order of 
%of ascending order:
% The last element as the most influence
% G is for generate: Make this function
\STATE $I_{\Delta_{+}} := G_{ \Delta_{+}}(P,E)$

\STATE $i_{\Delta_{+}} := s$ %Index in I_delta

\STATE $i_p := 0$ %Prime index

\WHILE {$i_{\Delta_{+}} \geq 0$}
	\STATE $i_p := I_{\Delta_{+}}[ i_{\Delta_{+}} ]$

	%\STATE $\Delta_{+} := \Delta_{+}(P_{i+p})$

	\IF {$b(P,E) \Delta_{+}(P[i_p], E[i_p]) \geq 2$}
		\STATE \COMMENT{$E_{new}$ is the new exponents raising the exponent that
		allows the number to be abundant}
		\STATE $E_{new} := E$
		\STATE $E_{new}[ i_p ] := E_{new}[ i_p ] + 1 $
		
		\IF {$primative(P, E_{new})$}
			\STATE $A := A\&(P,E)$
			\STATE $e_{found} := $ TRUE
		\ENDIF

		\STATE $i_{\Delta_{+}} := i_{\Delta_{+}} - 1$  
	
	\ELSE
		\STATE break;
	\ENDIF
\ENDWHILE


\IF {$i_{\Delta_+} \geq 0$}
	\STATE \COMMENT{Not all indexed exponents
	were able to make an abundant when raised one power}
	\IF {$expIncAlg(P, E, A, I_{\Delta_{+}}, i_{\Delta_{+}})$}
		\STATE $e_{found} := $ TRUE
	\ENDIF
\ENDIF

\end{algorithmic}
expIncAlg: Parameters - P, E, A, Indexed Delt+'s in order, current index
in last parameter

\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
\STATE $i_{\Delta_{+}}  := s$

\WHILE {$i_{\Delta_{+}} \geq 0$}
	\STATE \COMMENT{ exponent indicies that,when increased by 1, 
do not change the fact that n is deficient}
	\STATE $I_{b < 2} := \{I_{\Delta_{+}}[0], I_{\Delta_{+}}[1], 
	                       ..., I_{\Delta_{+}}[i_{\Delta_{+}}],\}$

	\IF {$mb(P, E, I) \geq 2$}
		\STATE \COMMENT{When other exponents that would not normally
cause n to be abundant by themselves are increased, this
exponent combined with other exponents in the stated situation
will eventually allow n to be an abundant number. Try increasing
it.}
		\STATE $E_{new} := E$
		
		%Exponent index:
		\STATE $e_i := I_{\Delta_{+}}[i_{\Delta_{+}}]$
		\STATE $E_{new}[e_i] := E_{new}[e_i] + 1$

		% TODO: here we start at i_delt+. How can we assume this?
		% Is it okay to start from the beginning to avoid this assumption?

    % TOO HARD TO PROVE, we shold not assume

		% I think we can assume because if one exponet prime set changes,
		% then I shifts over none or by one. If none, we are double
		% checking the prime-exp-pair
		% otherwise should we move back one or is this fine?

		%                                           _ | _
		%                                            \|/
    %                                             .
		\IF {$OrderDelPos(P, E_{new}, A |P| - 1)$}%, i_{\Delta_{+}})$}
			\STATE $e_{found} :=$ TRUE
		\ENDIF

	\STATE $i_{\Delta_{+}} :=  i_{\Delta_{+}} - 1$

	\ENDIF 

\ENDWHILE

\end{algorithmic}


TODO: DISCUSSION ON HOW THIS ALGORITHM WORKS?

\begin{proof}
  In order to prove that this theorem we need to show that if $n$
is primative with prime factors composing $P$ then $n$ 
will be gathered by this algorithm. Suppose that $n$ has the
prime factorization $n = p_0^{m_0} p_1^{m_1} ...
p_{d-1}^{m_{d-1}}$, where the prime factors $P$ follow the
conditions $b_1(P) < 2$ and $b_{\infty}(P) \geq 2$. Also note 
that $n$ has the property described in Theorem
{\ref{del_minus_thm}}, as $n$ is a primative abundant number. 
We want to show that the algorithm will gather the exponents 
$m_0, m_1, ..., m_{d-1}$. 

  First assume that all exponents of $n$ are one. Then this
algorithm will check if $n$ is primative, which it is, and
terminate. Thus this algorithm terminates and finds the only
possible $n$ with prime divisors composing P. 

%The theorem can be stated as Let $n$ be a compsite number whose
%prime divisors compose n. if $n$ is primative abundant, then this algorithm
%will find $n$. Therefore, we can attempt the contradition or
%contra positive. The contradiction would be this algorithm will
%not find $n$ for some primative abundant $n$.

  We now assume that at least one exponent $m_t$ is greater than
two, hence $b_1(P) < 2$. Suppose, to the contrary, that $n$ is not
obtained with the above algorithm, where $n$ is primative(When
this algorithm runs, we will have that $(P,E) \notin A$). Note that 
$n' = p_0^{m_0}...p_t^{m_t - 1}...p_{d-1}^{m_{d-1}}$ is deficient 
because $n$ is primative and therefore all of the divisors of $n$
are deficient. 

  The algorithm may pass this divisor of $n$, or perhaps it may
not. We proceed by cases:

\textbf{Case 1:}
  If the algorithm passes some deficient divisor of the above form, 
i.e. $E' = \{m_0, m_1, ..., m_t - 1, ..., m_d \}$ occurrs in this 
algorithm, we want to determine where it will occurr such that 
$m_t - 1$ is not increased by the algorithm. $E'$ can occurr for
the first time at one of three possible places: In $expAbundant$, 
$orderDelPos$ or $ExpIncAlg$.

\textbf{Case 1.1:}  
  Suppose that the algorithm passed $E'$ in expAbundant. If this
is the case, then all of the exponents in the prime factorization
of $n'$ are $1$. This is because the algorithm only passes
$expAbundant$ at the very beginning, and that is when all elements
in $E$ are one. As this is a deficient number, the $expAbundant$
will return the value of $orderDelPos(P,E,A,|P| - 1)$.


  Recall that $G_{Delta_+}$ is the sequence of $\Delta_+(p_j e_j)$
where $p_j = P[j]$ and $e_j = E[j]$ ordered from least to greatest.
The loop will check to see what exponent increases will lead to
abundant numbers, and by checking the end of $G\Delta_+(p_j, e_j)$
first, the algorithm will check the exponents of greatest
influence first, i.e. the exponent which, if increased, will
increase $b(P,E)$ the most. The loop will terminate once it
has found all primes whose exponent increased by one makes an
abundant number. We know that $n = p_0^1 p_2^1 ... p_t^2...
p_{d-1}^1$ as $n' = p_0^1 ... p_t^1 ... p_{d-1}^1$.
 Clearly, rasing the exponent of $p_t$ in $n'$ by one will
produce an abundant number as $n = p_0^{1} ... p_t^{2} ...
p_{d-1}^1$ is primative abundant. Thus the loop will check if $n$
is primative, which it is, and therefore $(P,E) \in A$, which we
assumed was false.

\textbf{Case 1.2:}
  Suppose that the algorithm creates $E'$ for the first time in
$orderDelPos$. The only place in which any exponent set is created
or updated is where $E_{new}$ is created here:
\begin{algorithmic}
 
	\IF {$b(P,E) \Delta_{+}(P[i_p], E[i_p]) \geq 2$}
		\STATE $E_{new} := E$
		\STATE $E_{new}[ i_p ] := E_{new}[ i_p ] + 1 $
		
		\IF {$primative(P, E_{new})$}
			\STATE $A := A\&(P,E)$
			\STATE $e_{found} := $ TRUE
		\ENDIF 

  \ENDIF
\end{algorithmic}

  Thus we suppose that $E'$ is obtained here as $E_{new} = E'$.
However, the condition of the if-statement above implies that
$E_{new} = E'$ is such that $b(P,E_{new}) = b(P,E') > 2$, which
implies that $n'$ is abundant. This contradicts the fact that $n'$
is a deficient as it is a divisor of a primative abundant number.
deficient. Thus $E'$ can't be obtained in OrderDelPos.

\textbf{Case 1.3:}
  Suppose that the algorithm creates $E'$ for the first time in
$expIncAlg$. $E'$ would, again, be concieved as $E' = E_{new}$. 

\begin{algorithmic}
\WHILE {$i_{\Delta_{+}} \geq 0$}
  \STATE $I_{b < 2} := \{I_{\Delta_{+}}[0], I_{\Delta_{+}}[1], 
	                       ..., I_{\Delta_{+}}[i_{\Delta_{+}}],\}$

	\IF {$mb(P, E, I) \geq 2$}

  	\STATE $E_{new} := E$
		
		\STATE $e_i := I_{\Delta_{+}}[i_{\Delta_{+}}]$
		\STATE $E_{new}[e_i] := E_{new}[e_i] + 1$

  	\IF {$OrderDelPos(P, E_{new}, A, |P| - 1)$}
			\STATE $e_{found} :=$ TRUE
		\ENDIF

	\STATE $i_{\Delta_{+}} :=  i_{\Delta_{+}} - 1$

	\ENDIF 

\ENDWHILE

\end{algorithmic}

If this is the case, $E'$ will be run through $OrderDelPos(P, E',
A, |P| - 1)$. Here we will have that the exponents of $E'$ that
will make $E'$ abundant will be raised, and since raising $m_t -1$
will make an abundant number, we have that $n$ will be discovered
in the algorithm, a desired contradiction.


\textbf{Case 2:}
  If the algorithm does not pass any of the deficient numbers in
the form $n' = p_0^{m_0}...p_{t}^{m_t - 1}...p_{d-1}^{m_{d-1}}$ , then 
we want to show that $n$ is not a primative abundant number. 

TODO: Think about proving this
\end{proof}

\subsection{Properties of the Exponent Algorithm}

\begin{theorem}[Property 1]

\end{theorem}

\begin{theorem}[The Fundamental Property]:
Let $q \leq r$ be primes. Suppose that $p_0, p_1, p_2, ..., 
p_{l-2}, q$ are the first l divisors of some primative abundant
odd with $d$ prime divisors. Suppose $p_0, p_1, ..., p_{l-2},r$ 
are also the first $l$ divisors of some primative abundant odd
with $d$ prime divisors. Then, given any prime $s$ such that $q \leq s 
\leq r$, we have that $p_0, p_1,..., p_{l-2}, s$ are the first $l$
divisors of some primative abundant odd with $d$ divisors.
\end{theorem}

\begin{proof}
  TODO: Use the exponent algorithm.
\end{proof}


%upp 
%Work backwards until exponents are all one? Show that $n$ will
% be found?
%Properties of this algorithm important?

%The issue with the below statement is it assumes the thing we are
%trying to prove, so contradiction will be used above instead.

%Thus, $n$ was either discovered in the 
%\textbf{if} $primative(P,E_{new})$ statement of OrderDelPos or
%expIncAlg. Suppose that $n$ was discovered in OrderDelPos

%% Old stuff where we assumed we did not have to change indicies
%would normally go here, but that makes the proof extemely
%difficult. It is probably commented out hiding at the bottom.


%We denote the first version of $I_{b>2}$ as $I_{max}$, i.e. the
%version that was first created when the while loop ran for the
%first time. We want to show that $t \in I_{max}$.

%If $t \notin I_{max}$ then we have that t was possibly increased
%in 

%of this loop if it was in a
%previous version of $I_{b>2}$, i.e. the 
% See notebook


% 
% Two MORE cases: t = i_{\Delta} or t != i_delta
% We need to show that if t = i_{\delta} then
% upon regeneration of G we will not move t.
% Note when m_t is increased it will
% have LESS influence on G and therefore 
% t will be moved up.
% that 



%
%We
%first show that $t \in I_{b > 2}$ 

% Either t in I or t notin I

%  Suppose that $t \notin I_{b > 2}$. Also,
%let $E''$ be the exponent set that was used to create $E_{new}$.
%Thus $E'' = \{m_0, m_1, ..., m_t - 1, ..., m_u - 1, ..., m_{d-1}\}$, 
%$E'' = \{m_0, m_1, ..., m_t - 2, ..., m_{d-1}\}$ or $E'' = \{ m_0,
%m_1, ..., m_u - 1, ..., m_t - 1, ... m_{d-1}\}$. 

%If $E'' = \{m_0, m_1, ..., m_t - 2, ..., m_{d-1}\}$, then the
%algorithm raised $m_t$ by one to create $E'$, and therefore 
%$\Delta_+(p_t, m_t - 2) = I_{del}[]$
%2 =

%i_(\Delta_+)$ which implies $t = i_{\Delta_+}$. 


%Then we have that $I_{\Delta_+} = G_{\Delta_+}(P, E'')$. 
%In order to achive a desired contradiction, We need to have that 
%$t \in I_{b > 2}$. If 


\end{document}
