\documentclass[../paper.tex]{subfiles}

\begin{document}

\section{Exponent Theorems and Algorithm}

In this section we will understand some of the conditions that
exponents of primative abundant odd numbers must follow. In order
to do this we first must define some functions and prove theorems 
that will allow us to determine some meaningful information about
exponents of primative abundant odds.

We Want to define $G_{\Delta_{+}}(P,E)$ as a function which lists
the indicies $i$ of prime/exponent pairs in sequences P and E
in order of least $\Delta_{+}(p_i, e_i)$ to greatest.
\\

To demonstrate the above function, we calculate 
$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\})$.

First we calculate each of $\Delta_{+}(3,1)$, $\Delta_{+}(5,2)$, 
and $\Delta_{+}(11,1)$. We find that 
$\Delta_{+}(3,1) = \frac{13}{12}$,
$\Delta_{+}(5,2) = \frac{156}{155}$, and
$\Delta_{+}(11,1)= \frac{133}{132}$.
Thus the order of $\Delta_{+}$ is as follows:

$$ \Delta_{+}(3,1) > \Delta_{+}(11,1) > \Delta_{+}(5,2)$$

Giving the primes indicies based off its order in the prime
factorization of $3^1 5^2 11^1$ starting at zero, we obtain that

$$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\}) = \{1,2,0\}$$
\\

We also need some theorems on determining when numbers are 
primative abundants and not just abundant.

No divisor of a primative abundant number is abundant, so 
we have that decreasing any exponent of any prime factor will
produce a deficient number. Thus we formally prove the below
theorem.

\begin{theorem}\label{del_minus_thm}
Suppose a number $n = p_1^{m_1} p_2^{m_2} ... p_d^{m_d}$ is 
abundant. Then $n$ is primative if and only if the 
following property holds:

Given any index of any prime/exponent pair $i$, we have that
$$b(n) \Delta_{-}(p_i, e_i) = b(p_1^{m_1} p_2^{m_2} ...  
p_i^{m_i - 1} p_{i+1}^{m_{i+1}}... p_d^{m_d}) < 2$$
\end{theorem}

\begin{proof}
	First suppose that $n$ is a primative abundant. Then any divisor of $n$
is deficient. Since decreasing any exponent in the prime 
factorization of $n$ produces a divisor of $n$, and since any
divisor of $n$ is deficient by nature of $n$ being primative,
we have that 
$$b(p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d{m_d}) < 2$$
Thus the property holds.

	Suppose the property holds, and that $n$ is abundant. Suppose $d$
is a proper divisor of $n$. Since $d$ is a proper divisor, it must
be a divisor smaller than $n$. Thus at least one of its prime factors
will have multiplicity less than $n$. This implies that $d$ is a 
divisor of
$n' = p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d{m_d})$ 
for some $i$ such that $1 \leq i \leq d$. Hence $b(d) \leq b(n')$.
Since our property holds, we have that $b(n') < 2$. Since $d$ is
a divisor of $n'$, we have that $b(d) \leq b(n') < 2$. Thus we
have that all proper divisors of $n$ are deficient, and hence $n$ is 
a primative abundant number.
\end{proof}

Suppose $P = \{p_0, p_1, ...,p_{d-1}\}$ are primes and 
$E = \{e_0, e_1, ..., e_{d-1} \}$ are positve integers.
We define $primative(P,E)$ as a statement that yeilds true
if $p_0^{e_0} p_1^{e_1} ... p_{d-1}^{e_{d-1}}$ is a primative
abundant number, and false otherwise.
%TODO: ADD theorem? what does this mean?

\begin{theorem} 
Let $P$ be a set of $d$ odd primes. If $b_{\infty}(P) > 2$, then the 
following algorithm will extract all primative
abundant odd numbers whose prime divisors compose $P$.
\end{theorem}
% The algorithm:
%
% * Set initial exponents to 1 
%
% * Check if abundant. If so check if primative
%   * If not primative, no abundant odds 
%		* If primative, this is 
%
% * If b(p1^e1 p2^e2 ... pd^ed) >= 2
%		* If primative this is an option : return true
%		* If not return false
%
%	* Check to see if any exponent increases will cause abundance
%    If any do cause abundance, check if primative.
%    Always start with the exponents of highest 'influence'
%		 then move on to lower 'influence' exponents. influence
%    is measured by which exponents increase b(n) the most
%    Del_pos is exactly the measure of this.
%
%	* Once the first exponent which does not cause abundance is found
%    we want to check which exponents can be raised to 'infinity'
%    to eventually produce an abundant number. We raise the exponents
%    NEED TO TALK ABOUT ORDER OF INFLUENCE HERE. IN THE ALGORITHM
%    WE ASSUME INFINITE INFLUENCE IS DIRECTLY RELATED TO FINITE
%    SINGLE EXPONENT INFLUENCE? IS THIS TRUE? I DONT KNOW.
%				*Infinite influence: Take a prime-exp pair p^e -> p^infinity
%				*Finite influence  : Take a prime-exp pair p^e -> p^(e+1)
%       Are they related?
% ^ * Mixed b: Raise exponents of low influence pairs to see if they
%     mixed with others will eventually go on to infinity
% ^ * If so raise 

% THIS is going to be UGLY.
% NEW THEorem added - may be important

\textit{In the below algorithm, the set of primes P is indexed 
starting at 0, not 1. In other words, $P = \{p_0, p_1, ..., p_{d-1}\}$}



{\setlength{\parindent}{0cm}

\textbf{The main algorithm}

\textbf{INPUT:} The set of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$.

\textbf{OUTPUT:} All primative abundant odds whose prime factors
compose $P$

}


\begin{algorithmic}
%E represents exponents

\STATE $E := \{e_0 = 1,e_1 = 1,...,e_n = 1\}$
\STATE $A := \{ \}$ %primative-abunant odds

\STATE $expAbundant(P, E, A)$

\RETURN $A$

\end{algorithmic}

{\setlength{\parindent}{0cm}

\textbf{Algorithm: expAbundant}

\textbf{INPUT:} The set of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, the exponents to those 
primes $E$, and the primative abundants found so far, $A$.

\textbf{OUTPUT:} True or false, depending on if the algorithm has found any
primative abundant numbers.

}

\begin{algorithmic}
\IF {$b(P, E) \geq 2$}
	\IF {$primative(P, E)$}
		\STATE $A := A \& (P,E)$
		\RETURN TRUE
	\ENDIF
	\RETURN FALSE
\ENDIF

\RETURN $orderDelPos(P,E,A,|P| - 1)$

\end{algorithmic}

{\setlength{\parindent}{0cm}

\textbf{Algorithm: orderDelPos}

\textbf{INPUT:} The set of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, exponents $E = \{ m_0, m_1, ...\}

\textbf{OUTPUT:} All primative abundant odds whose prime factors
compose $P$

}


orderDelPos:
Parameters: pset, expset, A, startat)

\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
%Index of delta_pos in order of 
%of ascending order:
% The last element as the most influence
% G is for generate: Make this function
\STATE $I_{\Delta_{+}} := G{ \Delta_{+}}(P,E)$

\STATE $i_{\Delta_{+}} := s$ %Index in I_delta

\STATE $i_p := 0$ %Prime index

\WHILE {$i_{\Delta_{+}} \geq 0$}
	\STATE $i_p := I_{\Delta_{+}}[ i_{\Delta_{+}} ]$

	%\STATE $\Delta_{+} := \Delta_{+}(P_{i+p})$

	\IF {$b(P,E) \Delta_{+}(P[i_p], E[i_p]) \geq 2$}
		\STATE \COMMENT{$E_{new}$ is the new exponents raising the exponent that
		allows the number to be abundant}
		\STATE $E_{new} := E$
		\STATE $E_{new}[ i_p ] := E_{new}[ i_p ] + 1 $
		
		\IF {$primative(P, E_{new})$}
			\STATE $A := A\&(P,E)$
			\STATE $e_{found} := $ TRUE
		\ENDIF

		\STATE $i_{\Delta_{+}} := i_{\Delta_{+}} - 1$  
	
	\ELSE
		\STATE break;
	\ENDIF
\ENDWHILE


\IF {$i_{\Delta_+} \geq 0$}
	\STATE \COMMENT{Not all indexed exponents
	were able to make an abundant when raised one power}
	\IF {$expIncAlg(P, E, A, I_{\Delta_{+}}, i_{\Delta_{+}})$}
		\STATE $e_{found} := $ TRUE
	\ENDIF
\ENDIF

\end{algorithmic}
expIncAlg: Parameters - P, E, A, Indexed Delt+'s in order, current index
in last parameter

\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
\STATE $i_{\Delta_{+}}  := s$

\WHILE {$i_{\Delta_{+}} \geq 0$}
	\STATE \COMMENT{ exponent indicies that,when increased by 1, 
do not change the fact that n is deficient}
	\STATE $I_{b < 2} := \{I_{\Delta_{+}}[0], I_{\Delta_{+}}[1], 
	                       ..., I_{\Delta_{+}}[i_{\Delta_{+}}],\}$

	\IF {$mb(P, E, I) \geq 2$}
		\STATE \COMMENT{When other exponents that would not normally
cause n to be abundant by themselves are increased, this
exponent combined with other exponents in the stated situation
will eventually allow n to be an abundant number. Try increasing
it.}
		\STATE $E_{new} := E$
		
		%Exponent index:
		\STATE $e_i := I_{\Delta_{+}}[i_{\Delta_{+}}]$
		\STATE $E_{new}[e_i] := E_{new}[e_i] + 1$

		% TODO: here we start at i_delt+. How can we assume this?
		% Is it okay to start from the beginning to avoid this assumption?

		% I think we can assume because if one exponet prime set changes,
		% then I shifts over none or by one. If none, we are double
		% checking the prime-exp-pair
		% otherwise should we move back one or is this fine?

		%                                 _ | _
		%                                  \|/
    %                                   .
		\IF {$OrderDelPos(P, E_{new}, A, i_{\Delta_{+}})$}
			\STATE $e_{found} :=$ TRUE
		\ENDIF

	\STATE $i_{\Delta_{+}} :=  i_{\Delta_{+}} - 1$

	\ENDIF 

\ENDWHILE

\end{algorithmic}

\begin{proof}
  In order to prove that this theorem we need to show that if $n$
is primative with prime factors composing $P$ then $n$ 
will be gathered by this algorithm. Suppose that $n$ has the
prime factorization $n = p_0^{m_0} p_1^{m_1} ...
p_{d-1}^{m_{d-1}}$, where the prime factors $P$ follow the
conditions $b_1(P) < 2$ and $b_{\infty}(P) \geq 2$. Also note 
that $n$ has the property described in Theorem
{\ref{del_minus_thm}}, as $n$ is a primative abundant number. 
We want to show that the algorithm will gather the exponents 
$m_0, m_1, ..., m_{d-1}$. 

  First assume that all exponents of $n$ are one. Then this
algorithm will check if $n$ is primative, which it is, and
terminate. Thus this algorithm terminates and finds the only
possible $n$ with prime divisors composing P. 

%The theorem can be stated as Let $n$ be a compsite number whose
%prime divisors compose n. if $n$ is primative abundant, then this algorithm
%will find $n$. Therefore, we can attempt the contradition or
%contra positive. The contradiction would be this algorithm will
%not find $n$ for some primative abundant $n$.

  We now assume that at least one exponent $m_i$ is greater than
two, hence $b_1(P) < 2$. Suppose, to the contrary, that $n$ is not
obtained with the above algorithm, where $n$ is primative. Note that 
$p_0^{m_0}...p_i^{m_i - 1}...p_{d-1}^{m_{d-1}}$ is deficient because 
$n$ is primative. If the algorithm passes this deficient number, 
i.e. $E = \{m_0, m_1, ..., m_i - 1, ..., m_d \}$ occurrs in this 
algorithm, we want to determine where it will occurr such that 
$m_i - 1$ is not increased by the algorithm. If $E$ is 
%Work backwards until exponents are all one? Show that $n$ will
% be found?
%Properties of this algorithm important?

%The issue with the below statement is it assumes the thing we are
%trying to prove, so contradiction will be used above instead.

Thus, $n$ was either discovered in the 
\textbf{if} $primative(P,E_{new})$ statement of OrderDelPos or
expIncAlg. Suppose that $n$ was discovered in OrderDelPos.


\end{proof}

TODO: PROPERTIES of THE ABOVE ALGORITHM~



\end{document}
