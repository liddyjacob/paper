%\documentclass[../paper.txt]{article}
\documentclass[../paper.tex]{subfiles}
\begin{document}
\section{Exponent Theorems and The Exponent Algorithm}

Let $r$ and $n$ be positive integers such that $r$ divides $n$. We
say $r$ is a divisor of $n$ of order $0$ if and only if $r = n$.
For each $i \geq 1$, we say that $r$ is a divisor of $n$ of order
$i$ in case there exists a prime $p$ such that $pr$ is a divisor
of $n$ of order $i - 1$. We remark that each divisor $r$ of $n$ has a 
unique well-defined order $k$ for some nonnegative integer $k$. For example, 
$3^2 5^1 13^1$ is a divisor of $3^3 5^2 13^1$ of order $2$. 

A related notion is \textit{incomplete primes}. Suppose $r$ divides 
$n$, and $p$ is a prime. We say that $p$ is incomplete in $r$ with 
respect to $n$ if $pr$ divides $n$. In this case, if $r$ is a divisor 
of $n$ of order $k$, then $pr$ is a divisor of $n$ of order $k - 1$.
$2$ is incomplete in $18$ with respect to $72$.

Yet another notion is \textit{crucial primes}. Let $n = \nu (P,E)$ 
be a positive integer. Suppose that $p \in P$. If $pn$ is
abundant, then we say that $p$ is a crucial prime for $n$. 
%Note that crucial primes have nothing to do with divisors.

For any given sequence of primes $P$ and corresponding sequence of
nonnegative exponents $E$, whose cardinalities are both $d$, we
wish to define $G_{\Delta_+}(P,E)$ as a particular ordering of
$\{0, 1, ..., d-1\}$. Given any distinct $i,j \in \{0, 1, ..., 
d - 1\}$, we order $G_{\Delta_+}(P, E)$ such that $i$ precedes 
$j$ in $G_{\Delta_+}(P, E)$ if $\Delta_+(p_i, e_i) \leq 
\Delta_+(p_j, e_j)$. In the case where  $\Delta_+(p_i, e_i) =
\Delta_+(p_j, e_j)$, it does not matter which element is the
predecessor or successor in $G_{\Delta_+}(P,E)$.

\begin{theorem}\label{g_ordering}
Suppose $n = \nu(P, E)$, where $P = \{p_0, p_1, ..., p_{d-1}\}$
and $E = \{e_0, ..., e_{d-1}\}$. Let $G_{\Delta_+}(P,E) = \{g_0, 
g_1, ..., g_{d-1}\}$. Then $b(n p_{g_i}) \leq b(n p_{g_j})$ when $i \leq j$.
\end{theorem}

The proof of {\ref{g_ordering}} follows directly from inequality
\ref{inc_ineq}.
\\
To demonstrate how $G_{\Delta_+}(P,E)$ is defined, we calculate
$G_{\Delta_+}(P,E)$ for $P = \{3, 5, 11\}$ and $E = \{1, 2, 1\}$.


First we calculate each of $\Delta_{+}(3,1)$, $\Delta_{+}(5,2)$, 
and $\Delta_{+}(11,1)$. We find that 
$\Delta_{+}(3,1) = \frac{13}{12}$,
$\Delta_{+}(5,2) = \frac{156}{155}$, and
$\Delta_{+}(11,1)= \frac{133}{132}$.
Listing these values in order from least to greatest, we have

$$\Delta_{+}(5,2) < \Delta_{+}(11,1) < \Delta_{+}(3,1).$$

Note $p_0 = 3$, $p_1 = 5$, and $p_2 = 11$. Since $\Delta_+(5,2)$
is the smallest while $p_1 = 5$, Our $G_{\Delta_{+}}(P, E)$ordering on $\{0, 1, 2\}$
begins with $1$. Since $\Delta_+(11,1)$ is the next smallest while
$p_2 = 11$, the corresponding index $2$ succedes $1$ in our
ordering on $\{0,1,2\}$. Finally, since $\Delta_+(3,1)$ is the largest
while $p_0 = 3$, the corresponding index $0$ succedes $2$ in our
ordering. Hence our ordering is $\{1, 2, 0\}$ and we write 
$G_{\Delta_+}(P,E) = \{1, 2, 0\}$ 

\begin{theorem}\label{crucial_thm}
Let $G_{\Delta_+}(P,E) = G$ for some integer $n = \nu (P,E)$.
Suppose $i$ precedes $j$ in $G$. If $p_i$ is crucial in n,
then $p_j$ is crucial in $n$. In other words, there exists some $g$
such that all elements that precede $G[g]$ are indices of non-crucial 
primes and all elements that succeed $G[g]$ are indices of crucial primes.
\end{theorem}

Informally, the above theorem states that $G_{\Delta_+}(P,E)$ 
$'$ looks like $'$

$$ G_{\Delta_+}(P, E) = (\text{... non-crucial prime indices} 
                        | \text{crucial prime indices...}) . $$
\begin{proof}

Suppose that
$p_i$ is crucial in $n$, so $2 \leq b(n p_i)$. Since $i$ precedes 
$j$ in $G$, Theorem {\ref{g_ordering}} tells us that $b(n p_i) \leq b(n
p_j)$. Thus $2 \leq b(n p_j)$, which tells us $p_j$ is crucial in $n$. 
If no $p_i$ is crucial in $n$, choose the highest possible index $g$ in $G$.


\end{proof}


\begin{theorem}\label{del_minus_thm}
Suppose a positive integer $n$ is abundant. Then $n$ is primitive if and 
only if all of its first order divisors are deficient.
\end{theorem}

\begin{proof}
	First suppose that $n$ is a primitive abundant and let $r$ be a
divisor of $n$ of order $1$. Since $r$ is a proper divisor of $n$,
indeed $r$ cannot be abundant and is therefore deficient.

	Suppose that every divisor of $n$ order $1$ is deficient. Let 
$r$ be any proper divisor in $n$. Then there exists a divisor $k$ 
of $n$ of order $1$ such that $r$ divides k. Since $k$ is 
deficient while $r$ divides $k$, indeed $r$ is deficient (Any divisor of a 
deficient number is deficient). Thus $n$
is abundant and all proper divisors of $n$ are deficient. By 
definition, $n$ is a primitive abundant number. 
\end{proof}

We now have enough tools to prove the theorem below.

\begin{theorem} 
Let $P$ be an increasing sequence of $d$ odd primes. The 
following algorithm will extract all primitive
abundant odd numbers whose prime divisors compose $P$.
\end{theorem}

\textit{In the below algorithm, the sequence of primes P is indexed 
starting at 0, not 1. In other words, $P = \{p_0, p_1, ...,
p_{d-1}\}$. Also, when a function is called, the arguments are
passed by reference. This means that a function may modify one of
its inputs.}

%\subfile{flowcharts/expflow.tex}

%--------------------------MAIN ALGORITHM------------------------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{The Exponent Algorithm(main)}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$.

\textbf{OUTPUT:} All primitive abundant odds whose prime factors
compose $P$
}
\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}[1]
%E represents exponents
\IF {$b_{\infty}(P) \leq 2$}
  \RETURN $\{\}$
\ENDIF

\STATE $E := \{e_0 = 1,e_1 = 1,...,e_n = 1\}$ \label{main::passed}
\STATE $A := \{ \}$ %primitive-abunant odds

\STATE $expAbundant(P, E, A)$

\RETURN $A$

\end{algorithmic}
\end{minipage}}
%----------------------------------------------------------------


%-------------------EXPONENT ABUNDANT ALGORITHM----------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{Algorithm: expAbundant}
\textit{(Check if $n$ is abundant with its current exponents)}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, the exponents to those 
primes $E$, and the primitive abundants found so far, $A$.

\textbf{OUTPUT:} No output. However, $A$ will be modified.
}

\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}[1]
\IF {$b(P, E) \geq 2$}
	\IF {$\nu(P, E)$ is primitive abundant}
		\STATE $A := A \& \nu (P,E)$
		\RETURN
	\ENDIF
	\RETURN
\ENDIF
\STATE $crucialAlg(P,E,A)$
\RETURN

\end{algorithmic}
\end{minipage}}
%-----------------------------------------------

%------------ ORDER DELTA POSITIVE --------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{Algorithm: crucialAlg}
\textit{(orders the $\Delta_+$ values)}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, exponents $E = \{ m_0, m_1,
...\}$, the set of primitive abundant numbers found $A$.

\textbf{OUTPUT:} True or False, depending on if the algorithm
found any primitive abundant numbers.
}

\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}[1]

\STATE $e_{found} :=$ FALSE
%Index of delta_pos in order of 
%of ascending order:
% The last element as the most influence
\STATE $G := G_{ \Delta_{+}}(P,E)$ \label{pos::G}
\STATE $g := |P| - 1$ %Index in I_delta

\STATE $i := 0$ %Prime index

\WHILE {$g \geq 0$} \label{pos::while}
	\STATE $i := G[g]$

	%\STATE $\Delta_{+} := \Delta_{+}(P_{i+p})$

	\IF {$p_i$ is crucial in $\nu(P, E)$} \label{pos::if}
		\STATE \COMMENT{$E_{new}$ is the new exponents raising the exponent that
		allows the number to be abundant}
		\STATE $E_{new} := E$
		\STATE $E_{new}[ i_p ] := E_{new}[ i_p ] + 1 $ \label{pos::passed}
		
		\IF {$\nu(P, E_{new})$ is primitive}
			\STATE $A := A\& \nu (P,E)$
			\STATE $e_{found} := $ TRUE
		\ENDIF

		\STATE $g := g - 1$  
	
	\ELSE
		\STATE break;
	\ENDIF
\ENDWHILE


\IF {$g \geq 0$}
	\STATE \COMMENT{Not all indexed exponents
	were able to make an abundant when raised one power}
	\IF {$mbAlg(P, E, A, g)$}
		\STATE $e_{found} := $ TRUE
	\ENDIF
\ENDIF

\RETURN $e_found$
\end{algorithmic}
\end{minipage}}

%-------------------------------------------------------


%------------------- EXP INC ALGORITHM -----------------

\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{Algorithm: mbAlg}
\textit{(exponent increasing algorithm)}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, the exponents to those 
primes $E$, the primitive abundants found so far $A$, and an
index, $s$.

\textbf{OUTPUT:} True or False.
}

\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}[1]

\STATE $e_{found} :=$ FALSE

\STATE $G = G_{\Delta_+}(P,E)$

\WHILE {$g \geq 0$} \label{alg::while}
%	\STATE \COMMENT{ exponent indices that,when increased by 1, 
%do not change the fact that n is deficient}
	\STATE $G_{b < 2} := \{G[0], G[1], 
	                       ..., G[g],\}$

	\IF {$mb(P, E, G_{b < 2}) > 2$}
		\STATE $E_{new} := E$	
		%Prime index
		\STATE $i_p := G[g]$
		\STATE $E_{new}[i_p] := E_{new}[i_p] + 1$\label{alg::passed}
		%?   ?    ??                      _ | _
		% ? ? ? ??  ??                     \|/
    %  ?   ?      ??                    .
    \IF {$crucialAlg(P, E_{new}, A)$}%, g)$}
			\STATE $e_{found} :=$ TRUE
		\ENDIF

	\STATE $g :=  g - 1$
	\ENDIF

\ENDWHILE

\RETURN $e_{found}$
\end{algorithmic}
\end{minipage}}

%-----------------------------------------------------
%TODO: DISCUSSION ON HOW THIS ALGORITHM WORKS?

\begin{proof}
  Let $n = \nu (Q, F)$ be an odd primitive abundant number for a
sequence of primes $Q$ and a sequence of positive integers $F$,
where $Q$ and $F$ have the same cardinality. We assume that 
$F$ contains some element not equal to $1$, otherwise the proof
is trivial. We want to show that
$n$ is collected in $A$, as this would prove our theorem.
Suppose that $m = \sum_{e \in F}(e)$

  Let $\ell$ be a divisor of $n$. Then $\ell = \nu (Q, F')$ for
some sequence of nonnegative integers $F'$. We say that $\ell$ is
\textit{passed} in the algorithm if the exponent sequence $F'$ is
stored in either $E$ or $E_{new}$ at some point when the algorithm is
being executed. The \textit{first appearance} of $\ell$ is the
first time in which $\ell$ is passed during the execution of the
algorithm.

  We want to show that $n$ is collected in this algorithm, and
later in this proof we will show that passing $n$ will force the
algorithm to collect $n$. In
order to show that $n$ is passed in the algorithm, we shall establish
a more general statement, namely that the algorithm will pass at least
one divisor of $n$ of the following orders: $\{m-d, m-d-1, ..., 0\}$.
Since $n$ itself is the only divisor of $n$ of order 0, this would be 
sufficient to establish the more general statement. We proceed by 
reverse induction.

Our base case is: \textit{The algorithm passes some divisor of order $m
- d$.} This is clearly true as $\ell = p_0 p_1 ... p_{d-1}$ is the 
first integer the algorithm passes, and this divisor has order 
$m-d$.

Our inductive step is:
\textit{Suppose the algorithm passes a divisor of order $k$,
where $0 < k \leq m - d $. We want to show there exists a divisor
of order $k - 1$ that is passed in this algorithm.}

Assume the inductive hypothesis is true for some divisor of $n$ of
order $k$. Denote this divisor $\ell_k = (Q, F_k)$. Note that
$\ell_k$ must make its first appeance whenever $E$ is modified
or an $E_{new}$ is initialized. Thus $\ell_k$ must make its first
appearance in one of two places: It can appear in $main$ in
line \ref{main::passed} or $mbAlg$ in line \ref{alg::passed}. 
Note that this divisor cannot appear in $crucialAlg$ in line
\ref{pos::passed}, for if $\ell_k$ did first appeared here, 
the if statement on line \ref{pos::if} would imply that $\ell_k$
is abundant.  

  We will now argue that regardless of where $\ell_k$ first
appears, the algorithm will call $crucialAlg$ with
parameters $P:= Q$, $E := F_K$, and $A := A$\footnote{The state of
$A$ does not matter}:
\\

Suppose that $\ell_k$ first appears in $main$ in line
\ref{main::passed}. The algorithm calls $expAbundant$ on 
line 8. Note that, 
as $k \neq 0$, we have that $b(\ell_k) < 2$. Thus the algorithm 
moves on to $crucialAlg(Q, F_k, A)$.
\\

Suppose that $\ell_k$ first appears in $mbAlg$ in line
\ref{alg::passed}. Notice that
the algorithm will immediately call $crucialAlg(Q, F_k, A)$ on the
very next line.
\\

As desired, $crucialAlg(Q, F_k, A)$ will be called.
\\
 
At this point we split off into cases, the case
where $k = 1$ and the case where $2 \leq k \leq m - d$. This is
important for our inductive step.

\textbf{Case 1:} Suppose that $2 \leq k \leq m - d$. In $crucialAlg(Q, F_k, A)$, notice 
that $G_{\Delta_+}(Q,F_k)$ is calculated on line \ref{pos::G}.
Since $k \geq 2$, we claim that
all incomplete primes in $\ell_k$ are not crucial primes.
Let $q$ be an incomplete prime in $\ell_k$. Then $\ell_k q \, |\, n$,
and in fact $\ell_k q$ has order $k - 1$. Since $k \geq 2$, we
have that $k - 1 \geq 1$. Thus $\ell_k q$ is a proper divisor of
$n$ and is therefore deficient. Thus $q$ is not a crucial prime in
$\ell_k$.

For convenience, we will refer to $G_{\Delta_+}(Q,F_k)$ by $G$. By 
Theorem {\ref{crucial_thm}}, there exists a positive integer $h$ such that
all elements that precede $G[h]$ are not indices of crucial primes
and all elements that succede $G[h]$ are indices of crucial
primes. Since $\ell_k$ contains at least one non-crucial prime (as
it contains at least incomplete prime), we know that this $h$ can
be chosen such that $G[h]$ is the index of some non-crucial prime.

Informally, we can see that $G$ is ordered in a way where all 
crucial prime indices are on the right (Theorem {\ref{crucial_thm}}), 
and all incomplete prime indices are on the left (as $k \geq 2$)
%
$$ G = \{ \text{... other indices and incomplete prime indices 
$ | $ crucial prime indices...} \} $$

We know that the while statement on line \ref{pos::while} in
$crucialAlg(Q, F_k, A)$ will terminate once $g = h$, as this point is the
first time where $g$ is the index of a non-crucial prime. When
the loop terminates, the algorithm will call $mbAlg(Q,F_k, A,
g)$, as $g \geq 0$. 

In $mbAlg(Q,F_k,A, g)$, we have that $g \geq 0$. Thus we will
descend into the while loop at line \ref{alg::while}. Notice 
that $G_{b<2} = \{G[0], G[1],
..., G[g]\}$. Thus $G_{b<2}$ contains all incomplete prime indices
of $\ell_k$. This allows us to state that $mb(Q,F_k, G_{b<2}) > 2$.

Consider the first time that $i = G[g]$ is the index of some
incomplete prime $p_i$ of $\ell_k$. At this point, 
all incomplete prime indices still exist in $G_{b<2}$. 
Thus $mb(Q, F_k, G_{b<2}) > 2$. Thus the execution of this
algorithm will reach line \ref{alg::passed} in $mbAlg$.
Now $p_i \ell_k$ will be passed in the algorithm, and $p_i \ell_k$
is a divisor of order $k-1$. Thus the inductive step has been proven.

\textbf{Case 2:} Suppose that $k = 1$. Recall that we are starting 
from $crucialAlg(Q,
F_k, A)$. In this case, we note that there is only one incomplete prime 
$p$ and it must be a crucial prime(as $l_k p = n$ is abundant)
As all crucial prime indices will pass the if statement on line
\ref{pos::if} in $crucialAlg$, we have that our incomplete prime's exponent will be 
increased and the result will be $n$. Therefore $n$ will be 
collected in $A$. Thus the inductive step has 
been proven. We have also shown that $n$ has been
collected in $A$ by the algorithm, proving the theorem.
\end{proof}

\end{document}
