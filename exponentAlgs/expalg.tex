%\documentclass[../paper.txt]{article}
\documentclass[../paper.tex]{subfiles}

    \newenvironment{hungitem}[1]%
{\noindent\mbox{#1}\\\begin{list}{}{\setlength{\leftmargin}{0.1\textwidth}}}
    {\end{list}}




\begin{document}

\section{Exponent Theorems and The Exponent Algorithm}

Let $r$ and $n$ be positive integers such that $r$ divides $n$. We
say $r$ is a divisor of $n$ of order $0$ if and only of $r = n$.
For each $i \geq 1$, we say that $r$ is a divisor of $n$ of order
$i$ in case there exists a prime $p$ such that $pr$ is a divisor
of $n$ of order $i - 1$. We remark that each divisor $r$ of $n$ has
order $k$ for some nonnegative integer $k$.

A related notion is \textit{incomplete primes}. Suppose $r$ divides 
$n$. We say that $p$ is incomplete in $r$ with respect to $n$ 
if $pr$ divides $n$. In this case, if $r$ is a divisor of $n$ of
order $k$, then $pr$ is a divisor of $n$ of order $k - 1$.

Yet another notion is \textit{crucial primes}. Let $n = \nu (P,E)$ 
be a positive integer. Suppose that $p \in P$. If $pn$ is
abundant, then we say that $p$ is a crucial prime in $n$. 
%Note that crucial primes have nothing to do with divisors.

For any given sequence of primes $P$ and corresponding sequence of
nonnegative exponents $E$, whose cardinalities are both $d$, we
wish to define $G_{\Delta_+}(P,E)$ as a particular ordering of
$\{0, 1, ..., d-1\}$. Given any distinct $i,j \in \{0, 1, ..., 
d - 1\}$, we order $G_{\Delta_+}(P, E)$ such that $i$ precedes 
$j$ in $G_{\Delta_+}(P, E)$ if $\Delta_+(p_i, e_i) < 
\Delta_+(p_j, e_j)$. In the case where  $\Delta_+(p_i, e_i) =
\Delta_+(p_j, e_j)$, it does not matter which element is the
predecessor or successor in $G_{\Delta_+}(P,E)$.

\begin{theorem}\label{g_ordering}
Suppose $n = \nu(P, E)$, where $P = \{p_0, p_1, ..., p_{d-1}\}$
and $E = \{e_0, ..., e_{d-1}\}$. Let $G_{\Delta_+}(P,E) = \{g_0, 
g_1, ..., g_{d-1}\}$. Then $b(n) < b(n p_{g_0}) \leq b(n p_{g_1})
\leq ... \leq b(n p_{g_{d-1}})$
\end{theorem}

The proof of {\ref{g_ordering}} is straightforward.
\\

To demonstrate how $G_{\Delta_+}(P,E)$ is defined, we calculate
$G_{\Delta_+}(P,E)$ for $P = \{3, 5, 11\}$ and $E = \{1, 2, 1\}$.


First we calculate each of $\Delta_{+}(3,1)$, $\Delta_{+}(5,2)$, 
and $\Delta_{+}(11,1)$. We find that 
$\Delta_{+}(3,1) = \frac{13}{12}$,
$\Delta_{+}(5,2) = \frac{156}{155}$, and
$\Delta_{+}(11,1)= \frac{133}{132}$.
Listing these values in order from least to greatest, we have

$$\Delta_{+}(5,2) < \Delta_{+}(11,1) < \Delta_{+}(3,1).$$

Note $p_0 = 3$, $p_1 = 5$, and $p_2 = 11$. Since $\Delta_+(5,2)$
is the smallest while $p_1 = 5$, the ordering on $\{0, 1, 2\}$
begins with $1$. Since $\Delta_+(11,1)$ is the next smallest while
$p_2 = 11$, the corresponding index $2$ succedes $1$ in our
ordering on $\{0,1,2\}$. Finally, since $\Delta_+(3,1)$ is the largest
while $p_0 = 3$, the corresponding index $0$ succedes $2$ in our
ordering. Hence our ordering is $\{1, 2, 0\}$ and we write 
$G_{\Delta_+}(P,E) = \{1, 2, 0\}$ 

\begin{theorem}\label{crucial_thm}
Let $G_{\Delta_+}(P,E) = G$ for some integer $n = \nu (P,E)$.
Suppose $i$ precedes $j$ in $G$. If $p_i$ is crucial in n,
then $p_j$ is crucial in $n$. In other words, there exists some $g$
such that all elements that precede $G[g]$ are not indices of
crucial primes and all elements that succeed $G[g]$ are indices of
crucial primes.
\end{theorem}

Informally, the above theorem states that $G_{\Delta_+}(P,E)$ 'looks like'

$$ G_{\Delta_+}(P, E) = (\text{... non-crucial prime indices} 
                        | \text{crucial prime indices...}) $$

\begin{proof}

Suppose that
$p_i$ is crucial in $n$, so $2 \leq b(n p_i)$. Since $i$ precedes 
$j$ in $G$, Theorem {\ref{g_ordering}} tells us that $b(n p_i) \leq b(n
p_j)$. Thus $2 \leq b(n p_j)$, which tells us $p_j$ is crucial in $n$.

\end{proof}


\begin{theorem}\label{del_minus_thm}
Suppose a positive integer $n$ is abundant. Then $n$ is primitive if and 
only if all of its first order divisors are deficient.
\end{theorem}

\begin{proof}
	First suppose that $n$ is a primitive abundant and let $r$ be a
divisor of $n$ of order $1$. Since $r$ is a proper divisor of $n$,
indeed $r$ cannot be abundant and is therefore deficient.

	Suppose that every divisor of $n$ order $1$ is deficient. Let 
$r$ be any proper divisor in $n$. Then there exists a divisor $k$ 
of $n$ of order $1$ such that $r$ divides k. Since $k$ is 
deficient while $r$ divides $k$, indeed $r$ is deficient. Thus $n$
is abundant and all proper divisors of $n$ are deficient. By 
definition, $n$ is primitive. 
\end{proof}

We now have enough tools to prove the theorem below.

\begin{theorem} 
Let $P$ be a sequence of $d$ odd primes. The 
following algorithm will extract all primitive
abundant odd numbers whose prime divisors compose $P$.
\end{theorem}

\textit{In the below algorithm, the sequence of primes P is indexed 
starting at 0, not 1. In other words, $P = \{p_0, p_1, ...,
p_{d-1}\}$. Also, when a function is called, the arguments are
passed by reference. This means that a function may modify one of
its inputs.}

%\subfile{flowcharts/expflow.tex}

%--------------------------MAIN ALGORITHM------------------------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{The Exponent Algorithm}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$.

\textbf{OUTPUT:} All primitive abundant odds whose prime factors
compose $P$
}
\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}
%E represents exponents
\IF {$b_{\infty}(P) \leq 2$}
  \RETURN $\{\}$
\ENDIF

\STATE $E := \{e_0 = 1,e_1 = 1,...,e_n = 1\}$
\STATE $A := \{ \}$ %primitive-abunant odds

\STATE $expAbundant(P, E, A)$

\RETURN $A$

\end{algorithmic}
\end{minipage}}
%----------------------------------------------------------------


%-------------------EXPONENT ABUNDANT ALGORITHM----------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{Algorithm: expAbundant}
\textit{(Check if $n$ is abundant with its current exponents)}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, the exponents to those 
primes $E$, and the primitive abundants found so far, $A$.

\textbf{OUTPUT:} No output. However, $A$ will be modified.
}

\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}
\IF {$b(P, E) \geq 2$}
	\IF {$\nu(P, E)$ is primitive}
		\STATE $A := A \& \nu (P,E)$
		\RETURN
	\ENDIF
	\RETURN
\ENDIF
$orderDelPos(P,E,A)$
\RETURN

\end{algorithmic}
\end{minipage}}
%-----------------------------------------------

%------------ ORDER DELTA POSITIVE --------------
\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{Algorithm: orderDelPos}
\textit{(orders the $\Delta_+$ values)}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, exponents $E = \{ m_0, m_1,
...\}$, the set of primitive abundant numbers found $A$.

\textbf{OUTPUT:} True or False, depending on if the algorithm
found any primitive abundant numbers.
}

\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
%Index of delta_pos in order of 
%of ascending order:
% The last element as the most influence
% G is for generate: Make this function
\STATE $G := G_{ \Delta_{+}}(P,E)$

\STATE $g := |P| - 1$ %Index in I_delta

\STATE $i := 0$ %Prime index

\WHILE {$g \geq 0$}
	\STATE $i := G[g]$

	%\STATE $\Delta_{+} := \Delta_{+}(P_{i+p})$

	\IF {$p_i$ is crucial in $\nu(P, E)$}
		\STATE \COMMENT{$E_{new}$ is the new exponents raising the exponent that
		allows the number to be abundant}
		\STATE $E_{new} := E$
		\STATE $E_{new}[ i_p ] := E_{new}[ i_p ] + 1 $
		
		\IF {$\nu(P, E_{new})$ is primitive}
			\STATE $A := A\& \nu (P,E)$
			\STATE $e_{found} := $ TRUE
		\ENDIF

		\STATE $g := g - 1$  
	
	\ELSE
		\STATE break;
	\ENDIF
\ENDWHILE


\IF {$g \geq 0$}
	\STATE \COMMENT{Not all indexed exponents
	were able to make an abundant when raised one power}
	\IF {$expIncAlg(P, E, A, g)$}
		\STATE $e_{found} := $ TRUE
	\ENDIF
\ENDIF

\RETURN $e_found$
\end{algorithmic}
\end{minipage}}

%-------------------------------------------------------


%------------------- EXP INC ALGORITHM -----------------

\noindent\fbox{\begin{minipage}{\linewidth}
{\setlength{\parindent}{0cm}

\textbf{Algorithm: expIncAlg}
\textit{(exponent increasing algorithm)}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, the exponents to those 
primes $E$, the primitive abundants found so far $A$, and an
index, $s$.

\textbf{OUTPUT:} True or False.
}

\noindent\rule{\textwidth}{1pt}
\begin{algorithmic}

\STATE $e_{found} :=$ FALSE

\STATE $G = G_{\Delta_+}(P,E)$

\WHILE {$g \geq 0$}
%	\STATE \COMMENT{ exponent indicies that,when increased by 1, 
%do not change the fact that n is deficient}
	\STATE $G_{b < 2} := \{G[0], G[1], 
	                       ..., G[g],\}$

	\IF {$mb(P, E, G_{b < 2}) > 2$}
		\STATE $E_{new} := E$	
		%Prime index
		\STATE $i_p := G[g]$
		\STATE $E_{new}[i_p] := E_{new}[i_p] + 1$
		%?   ?    ??                      _ | _
		% ? ? ? ??  ??                     \|/
    %  ?   ?      ??                    .
		\IF {$OrderDelPos(P, E_{new}, A$}%, g)$}
			\STATE $e_{found} :=$ TRUE
		\ENDIF

	\STATE $g :=  g - 1$
	\ENDIF

\ENDWHILE

\RETURN $e_{found}$
\end{algorithmic}
\end{minipage}}

%-----------------------------------------------------
TODO: DISCUSSION ON HOW THIS ALGORITHM WORKS?

\begin{proof}
  Let $n = \nu (P, E)$ be an odd primitive abundant number for a
sequence of primes $P$ and a sequence of positive integers $E$,
where $E$ and $P$ have the same cardinality. We want to show that
$n$ is collected in $A$, as this would prove our theorem.
We say that $m = \sum_{e \in E}(e)$

  Let $\ell = (P, E')$ be a divisor of $n$. We say that $\ell$ is
\textit{passed} in the algorithm if the exponent sequence $E'$ is
stored in either $E$ or $E'$ at some point when the algorithm is
being executed. The \textit{first appearance} of $\ell$ is the
first time in which $\ell$ is passed during the execution of the
algorithm.

  We will use reverse finite induction for our proof. We want to show that
the algorithm will pass at least one divisors of of order $m -
d, m - d + 1, m - d + 2, ..., 0$.

Our base case is: \textit{The algorithm passes divisor of order $m
- d$.} This is clearly true as $\ell = p_0 p_1 ... p_{d-1}$ is the 
first integer the algorithm passes, and this divisor has order 
$m-d$.

Our inductive step is:
\textit{Suppose the algorithm passes a divisor of order $k$,
where $0 < k \leq m - d $. We want to show there exists a divisor
of order $k - 1$ that is passed in this algorithm.}


Assume the inductive hypothesis is true for some divisor of $n$ of
order $k$. Denote this divisor $\ell_k = (P, E_k)$. Note that
$\ell_k$ can only make its first appeance whenever $E$ is modified
or an $E'$ is created. Thus $\ell_k$ can only make its first
appearance in one of two places: It can appear in $expAbundant$ or
$expIncAlg$. Note that this divisor cannot appear in $orderDelPos$
, for if $\ell_k$ first appeared here, the conditions for $\ell_k$ 
to first appear here would be such that $\ell_k$ is abundant.

  I will now argue that regardless of where $\ell_k$ first
appears, the algorithm will call $orderDelPos(P,E_k,A)$:
\\

Suppose that $\ell_k$ first appears in $expAbundant$. Note that, 
as $k \neq 0$, we have that $b(\ell_k) < 2$. Thus the algorithm 
moves on to $orderDelPos(P, E_k, A)$.
\\

Suppose that $\ell_k$ first appears in $expIncAlg$. Notice that
the algorithm will immediently check $orderDelPos(P, E_k, A)$.
\\

As desired, $orderDelPos(P, E_k, A)$ will be called.
\\
 
At this point it is important to split off into cases: The case
where $k = 1$ and the case where $2 \leq k \leq m - d$.

\textbf{Case 1($2 \leq k \leq m - d$):} In $orderDelPos$, notice 
that $G_{\Delta_+}(P,E_k)$ is formed. Since $k \geq 2$, we claim that
all incomplete primes in $\ell_k$ are \textit{non}-crucial primes.
Let $p$ be an incomplete prime in $\ell_k$. Then $\ell_k p | n$,
and in fact $\ell_k p$ has order $k - 1$. Since $k \geq 2$, we
have that $k - 1 \geq 1$. Thus $\ell_k p$ is a proper divisor of
$n$ and is therefore deficient. Thus $p$ is not a crucial prime in
$\ell_k$.

For convienience, we will refer to $G(P,E_k)$ as $G$. By Theorem
{\ref{crucial_thm}}, there exists positive integer $h$ such that
all elements that precede $G[h]$ are not indices of crucial primes
and all elements that succede $G[h]$ are indices of crucial
primes. Since $\ell_k$ contains at least one non-crucial prime (as
it contains at least incomplete prime), we know that this $h$ can
be chosen such that $G[h]$ is the index of some non-crucial prime.

Informally, we can see that $G$ is ordered in a way where all 
crucial prime indices are on the right (Theorem {\ref{crucial_thm}}), 
and all incomplete prime indices are on the left (as $k \geq 2$)

$$ G = \{ \text{... other indicies and incomplete prime indicies 
$ | $ crucial prime indicies...} \} $$

We know that the while statement
$orderDelPos$ will terminate once $g = h$, as this point is the
first time where $g$ is the index of a non-crucial prime. When
the loop terminates, the algorithm will call $expIncAlg(P,E_v, A,
g)$, as $g \geq 0$. 

In $expIncAlg(P,E_v,A, g)$, we have that $g \geq 2$. Thus we will
descend into the while loop. Notice that $G_{b<2} = \{G[0], G[1], 
..., G[g]\}$. Thus $G_{b<2}$ contains all incomplete prime indices
of $\ell_k$. Thus, when the incomplete exponents of each incomplete 
prime is raised high enough, the result will be $n$. 
Thus $mb(P,E_k, G_{b<2}) > 2$.

Consider the first time that $i = G[g]$ is the index of some
incomplete prime of $\ell_k$ with respect to $n$. At this point, 
all incomplete prime indices still exist in $G_{b<2}$. 
Thus $mb(P, E_k, G_{b<2} > 2$. 
Now $p_i \ell_k$ will be passed in the algorithm, and $p_i \ell_k$
is a divisor of order $k-1$. Thus the inductive step has been proven.

\textbf{Case 2 ($k = 1$):} We are starting from $OrderDelPos$,
where Case 1 started. In this case, we note that there is
only one incomplete prime and it must be a crucial prime.
As all crucial prime indicies will pass the first if statement in the 
loop, we have that our incomplete prime's exponent will be 
increased and the result will be $n$. $n$ is primitive, and
therefore $n$ will be collected in $A$. Thus the inductive step has 
been proven. In fact, we also have shown that $n$ has been
collected in $A$ by the algorithm, proving the theorem.
\\

\end{proof}

%NOTE THAT $3 * 5^6 * 7^3 * 67 * 73$ IS PRIMITIVE ABUNDANT,
%AND $3^2 * 5 * 7 * 107 * 109$ IS PRIMITIVE ABUNDANT,
%YET NO PRIMITIVE ABUNDANT WITH 5 DIVISORS EXISTS SUCH THAT
%ITS FIRST FOUR DIVISORS ARE $3,5,7$ AND $71$

%SOURCE: VAKDAS DICIUNAS,
%$https://klevas.mif.vu.lt/~valdas/Abundant_Numbers/$

%Notice that we are not far off. We are only missing about
%2 percent. And the exponent algorithm is in good condition.
%Great sifting assumption.


%IDEA IDEA IDEA!!
%Suppose that $p_1 ... p_{i-1} q$ fails in the opm algorithm. IDEA:
%We should find the maximum prime $q'$ such that $$p_1 ... p_{i-1}
%q' \in opm(i)$$. T
%hen we can start at that prime!!(Maybe )
%(Possibly)

%Why this idea?? 

%Consider the example above, where $\{3,5,7,73\}$ fails.
%Note that $\{3,5,7,73\} \in opm(4)$. In fact, \textit{the first
%prime after q' = 103 is 107}, and note that this prime will form a
%primitive abundant number in opm(5) with $3,5,7$. Thats the
%conjecture.

%The idea is that if the primest does not appear in opm(i), then it
%is not going to create an abundant number without another prime in
%d > i. We also may be able to prove that the last few primes q' in
%opm(i) are going to create nonprimitive abundants.

%CITE VALDAS for opm - odd primitive abundants.

\end{document}
