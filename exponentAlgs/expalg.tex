\documentclass[../paper.tex]{subfiles}

\begin{document}

\section{Exponent Theorems and Algorithm}

In this section we will understand some of the conditions that
exponents of primative abundant odd numbers must follow. In order
to do this we first must define some functions and prove theorems 
that will allow us to determine some meaningful information about
exponents of primative abundant odds.

We Want to define $G_{\Delta_{+}}(P,E)$ as a function which lists
the indicies $i$ of prime/exponent pairs in sequences P and E
in order of least $\Delta_{+}(p_i, e_i)$ to greatest.
\\

To demonstrate the above function, we calculate 
$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\})$.

First we calculate each of $\Delta_{+}(3,1)$, $\Delta_{+}(5,2)$, 
and $\Delta_{+}(11,1)$. We find that 
$\Delta_{+}(3,1) = \frac{13}{12}$,
$\Delta_{+}(5,2) = \frac{156}{155}$, and
$\Delta_{+}(11,1)= \frac{133}{132}$.
Thus the order of $\Delta_{+}$ is as follows:

$$ \Delta_{+}(3,1) > \Delta_{+}(11,1) > \Delta_{+}(5,2)$$

Giving the primes indicies based off its order in the prime
factorization of $3^1 5^2 11^1$ starting at zero, we obtain that

$$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\}) = \{1,2,0\}$$
\\

We also need some theorems on determining when numbers are 
primative abundants and not just abundant.

No divisor of a primative abundant number is abundant, so 
we have that decreasing any exponent of any prime factor will
produce a deficient number. Thus we formally prove the below
theorem.

\begin{theorem}
Suppose a number $n = p_1^{m_1} p_2^{m_2} ... p_d^{m_d}$ is 
abundant. Then $n$ is primative if and only if the 
following property holds:

Given any index of any prime/exponent pair $i$, we have that
$$b(n) \Delta_{-}(p_i, e_i) = b(p_1^{m_1} p_2^{m_2} ...  
p_i^{m_i - 1} p_{i+1}^{m_{i+1}}... p_d^{m_d}) < 2$$
\end{theorem}

\begin{proof}
	First suppose that $n$ is a primative abundant. Then any divisor of $n$
is deficient. Since decreasing any exponent in the prime 
factorization of $n$ produces a divisor of $n$, and since any
divisor of $n$ is deficient by nature of $n$ being primative,
we have that 
$$b(p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d{m_d}) < 2$$
Thus the property holds.

	Suppose the property holds, and that $n$ is abundant. Suppose $d$
is a proper divisor of $n$. Since $d$ is a proper divisor, it must
be a divisor smaller than $n$. Thus at least one of its prime factors
will have multiplicity less than $n$. This implies that $d$ is a 
divisor of
$n' = p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d{m_d})$ 
for some $i$ such that $1 \leq i \leq d$. Hence $b(d) \leq b(n')$.
Since our property holds, we have that $b(n') < 2$. Since $d$ is
a divisor of $n'$, we have that $b(d) \leq b(n') < 2$. Thus we
have that all proper divisors of $n$ are deficient, and hence $n$ is 
a primative abundant number.
\end{proof}

Suppose $P = \{p_0, p_1, ...,p_{d-1}\}$ are primes and 
$E = \{e_0, e_1, ..., e_{d-1} \}$ are positve integers.
We define $primative(P,E)$ as a statement that yeilds true
if $p_0^{e_0} p_1^{e_1} ... p_{d-1}^{e_{d-1}}$ is a primative
abundant number, and false otherwise.
%TODO: ADD theorem? what does this mean?

\begin{theorem} 
Let $P$ be a set of $d$ odd primes. If $b_{1}(P) \leq 2$
and $b_{\infty}(P) > 2$, then the following algorithm will extract all primative
abundant odd numbers whose prime divisors compose $P$.
\end{theorem}
% The algorithm:
%
% * Set initial exponents to 1 
%
% * Check if abundant. If so check if primative
%   * If not primative, no abundant odds 
%		* If primative, this is 
%
% * If b(p1^e1 p2^e2 ... pd^ed) >= 2
%		* If primative this is an option : return true
%		* If not return false
%
%	* Check to see if any exponent increases will cause abundance
%    If any do cause abundance, check if primative.
%    Always start with the exponents of highest 'influence'
%		 then move on to lower 'influence' exponents. influence
%    is measured by which exponents increase b(n) the most
%    Del_pos is exactly the measure of this.
%
%	* Once the first exponent which does not cause abundance is found
%    we want to check which exponents can be raised to 'infinity'
%    to eventually produce an abundant number. We raise the exponents
%    NEED TO TALK ABOUT ORDER OF INFLUENCE HERE. IN THE ALGORITHM
%    WE ASSUME INFINITE INFLUENCE IS DIRECTLY RELATED TO FINITE
%    SINGLE EXPONENT INFLUENCE? IS THIS TRUE? I DONT KNOW.
%				*Infinite influence: Take a prime-exp pair p^e -> p^infinity
%				*Finite influence  : Take a prime-exp pair p^e -> p^(e+1)
%       Are they related?
% ^ * Mixed b: Raise exponents of low influence pairs to see if they
%     mixed with others will eventually go on to infinity
% ^ * If so raise 

% THIS is going to be UGLY.
% NEW THEorem added - may be important

\textit{In the below algorithm, the set of primes P is indexed 
starting at 0, not 1. In other words, $P = \{p_0, p_1, ..., p_{d-1}\}$}

\begin{algorithmic}
%E represents exponents


{\setlength{\parindent{0cm}}

\textbf{The main algorithm}

\textbf{INPUT:} The set of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$.

\textbf{OUTPUT:} All primative abundant odds whose prime factors
compose $P$

}


\STATE $E := \{e_0 = 1,e_1 = 1,...,e_n = 1\}$
\STATE $A := \{ \}$ %primative-abunant odds

\STATE $expAbundant(P, E, A)$

\RETURN $A$

\end{algorithmic}

{\setlength{\parindent{0cm}}

\textbf{Algorithm: expAbundant}

\textbf{INPUT:} The set of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, the exponents to those 
primes $E$, and the primative abundants found so far, $A$.

\textbf{OUTPUT:} True or false, depending on if the algorithm has found any
primative abundant numbers.

}

\begin{algorithmic}
\IF {$b(P, E) \geq 2$}
	\IF {$primative(P, E)$}
		\STATE $A := A \& (P,E)$
		\RETURN TRUE
	\ENDIF
	\RETURN FALSE
\ENDIF

\RETURN $orderDelPos(P,E,A,|P| - 1)$

\end{algorithmic}

orderDelPos:
Parameters: pset, expset, A, startat)

\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
%Index of delta_pos in order of 
%of ascending order:
% The last element as the most influence
% G is for generate: Make this function
\STATE $I_{\Delta_{+}} := G{ \Delta_{+}}(P,E)$

\STATE $i_{\Delta_{+}} := s$ %Index in I_delta

\STATE $i_p := 0$ %Prime index

\WHILE {$i_{\Delta_{+}} \geq 0$}
	\STATE $i_p := I_{\Delta_{+}}[ i_{\Delta_{+}} ]$

	%\STATE $\Delta_{+} := \Delta_{+}(P_{i+p})$

	\IF {$b(P,E) \Delta_{+}(P[i_p], E[i_p]) \geq 2$}
		\STATE \COMMENT{$E_{new}$ is the new exponents raising the exponent that
		allows the number to be abundant}
		\STATE $E_{new} := E$
		\STATE $E_{new}[ i_p ] := E_{new}[ i_p ] + 1 $
		
		\IF {$primative(P, E_{new})$}
			\STATE $A := A\&(P,E)$
			\STATE $e_{found} := $ TRUE
		\ENDIF

		\STATE $i_{\Delta_{+}} := i_{\Delta_{+}} - 1$  
	
	\ELSE
		\STATE break;
	\ENDIF
\ENDWHILE


\IF {$i_{\Delta_+} \geq 0$}
	\STATE \COMMENT{Not all indexed exponents
	were able to make an abundant when raised one power}
	\IF {$expIncAlg(P, E, A, I_{\Delta_{+}}, i_{\Delta_{+}})$}
		\STATE $e_{found} := $ TRUE
	\ENDIF
\ENDIF

\end{algorithmic}
expIncAlg: Parameters - P, E, A, Indexed Delt+'s in order, current index
in last parameter

\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
\STATE $i_{\Delta_{+}}  := s$

\WHILE {$i_{\Delta_{+}} \geq 0$}
	\STATE \COMMENT{ exponent indicies that,when increased by 1, 
do not change the fact that n is deficient}
	\STATE $I_{b < 2} := \{I_{\Delta_{+}}[0], I_{\Delta_{+}}[1], 
	                       ..., I_{\Delta_{+}}[i_{\Delta_{+}}],\}$

	\IF {$mb(P, E, I) \geq 2$}
		\STATE \COMMENT{When other exponents that would not normally
cause n to be abundant by themselves are increased, this
exponent combined with other exponents in the stated situation
will eventually allow n to be an abundant number. Try increasing
it.}
		\STATE $E_{new} := E$
		
		%Exponent index:
		\STATE $e_i := I_{\Delta_{+}}[i_{\Delta_{+}}]$
		\STATE $E_{new}[e_i] := E_{new}[e_i] + 1$

		% TODO: here we start at i_delt+. How can we assume this?
		% Is it okay to start from the beginning to avoid this assumption?

		% I think it is because if one exponet prime set changes,
		% then I shifts over none or by one. If none, we are double
		% checking the prime-exp-pair
		% otherwise should we move back one or is this fine?

		%                                 _ | _
		%                                  \|/
    %                                   .
		\IF {$OrderDelPos(P, E_{new}, A, i_{\Delta_{+}})$}
			\STATE $e_{found} :=$ TRUE
		\ENDIF

	\STATE $i_{\Delta_{+}} :=  i_{\Delta_{+}} - 1$

	\ENDIF 

\ENDWHILE

\end{algorithmic}




\end{document}
