%\documentclass[../paper.txt]{article}
\documentclass[../paper.tex]{subfiles}

\begin{document}

\section{Exponent Theorems and Algorithm}

In this section we will understand some of the conditions that
exponents of primitive abundant odd numbers must follow. In order
to do this we first must define some functions and prove theorems 
that will allow us to determine some meaningful information about
exponents of primitive abundant odds.

We Want to define $G_{\Delta_{+}}(P,E)$ as a function which lists
the indicies $i$ of prime/exponent pairs in sequences P and E
in order of least $\Delta_{+}(p_i, e_i)$ to greatest.
\\

To demonstrate the above function, we calculate 
$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\})$.

First we calculate each of $\Delta_{+}(3,1)$, $\Delta_{+}(5,2)$, 
and $\Delta_{+}(11,1)$. We find that 
$\Delta_{+}(3,1) = \frac{13}{12}$,
$\Delta_{+}(5,2) = \frac{156}{155}$, and
$\Delta_{+}(11,1)= \frac{133}{132}$.
Thus the order of $\Delta_{+}$ is as follows:

$$ \Delta_{+}(3,1) > \Delta_{+}(11,1) > \Delta_{+}(5,2)$$

Giving the primes indicies based off its order in the prime
factorization of $3^1 5^2 11^1$ starting at zero, we obtain that

$$G_{\Delta_{+}}(\{3,5,11\}, \{1,2,1\}) = \{1,2,0\}$$
\\

We also need some theorems on determining when numbers are 
primitive abundants and not just abundant.

No divisor of a primitive abundant number is abundant, so 
we have that decreasing any exponent of any prime factor will
produce a deficient number. Thus we formally prove the below
theorem.

\begin{theorem}\label{del_minus_thm}
Suppose a number $n = p_1^{m_1} p_2^{m_2} ... p_d^{m_d}$ is 
abundant. Then $n$ is primitive if and only if the 
following property holds:

Given any index of any prime/exponent pair $i$, we have that
$$b(n) \Delta_{-}(p_i, e_i) = b(p_1^{m_1} p_2^{m_2} ...  
p_i^{m_i - 1} p_{i+1}^{m_{i+1}}... p_d^{m_d}) < 2$$
\end{theorem}

\begin{proof}
	First suppose that $n$ is a primitive abundant. Then any divisor of $n$
is deficient. Since decreasing any exponent in the prime 
factorization of $n$ produces a divisor of $n$, and since any
divisor of $n$ is deficient by nature of $n$ being primitive,
we have that 
$$b(p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d^{m_d}) < 2$$
Thus the property holds.

	Suppose the property holds, and that $n$ is abundant. Suppose $d$
is a proper divisor of $n$. Since $d$ is a proper divisor, it must
be a divisor smaller than $n$. Thus at least one of its prime factors
will have multiplicity less than in $n$. This implies that $d$ is a 
divisor of
$n' = p_1^{m_1} p_2^{m_2} ...   p_i^{m_i - 1} p_{i+1}^{m_{i+1}}
... p_d^{m_d}$ 
for some $i$ such that $1 \leq i \leq d$. Hence $b(d) \leq b(n')$.
Since our property holds, we have that $b(n') < 2$. Since $d$ is
a divisor of $n'$, we have that $b(d) \leq b(n') < 2$. Thus we
have that all proper divisors of $n$ are deficient, and hence $n$ is 
a primitive abundant number.
\end{proof}

We define the order of a divisor d (with respect to some multiple
$n$) as the difference in the sum of the exponents between a
divisor and some multiple of that divisor. Suppose $n = p_0^{m_0}
p_1^{m_1} ... p_{d-1}^{m_{d-1}}$ is an integer and $d = p_0^{\ell_0}
p_1^{\ell_1} ... p_{d-1}^{\ell_{d-1}}$. As $d$ is a divisor of
$n$, we have that $m_i \leq \ell_i$ for each $i$. The
\textit{order of $d$ with respect to $n$} is defined as $\sum {m_i
- \ell_i}$. If $d$ is not a divisor of $n$, then the order of $d$
is undefined and meaningless. If the prime factorization of $d$ is
missing some prime factor, then the exponent of that prime factor
is zero.

A related notion is \textit{incomplete exponents}. Let $n$ be a
primitive abundant number. Let $d$ be a divisor of that number.
Write $n$ and $d$ as $n = p_0^{m_0} p_1^{m_0}...
p_{d-1}^{m_{d-1}}$ and $d$ as $d = p_0^{m'_0} p_1^{m'_0} ...
p_{d-1}^{m'_{d-1}}$. We say an exponent $m'_i$ is incomplete in
$d$ if $m'_i < m_i$. 

Suppose $P = \{p_0, p_1, ...,p_{d-1}\}$ are primes and 
$E = \{e_0, e_1, ..., e_{d-1} \}$ are positve integers.
We define $primitive(P,E)$ as a statement that yeilds true
if $p_0^{e_0} p_1^{e_1} ... p_{d-1}^{e_{d-1}}$ is a primitive
abundant number, and false otherwise.
%TODO: ADD theorem? what does this mean?

%TODO: Talk about subtraction order divisors and immedient
%divisors.



\begin{theorem} 
Let $P$ be a sequence of $d$ odd primes. If $b_{\infty}(P) > 2$, then the 
following algorithm will extract all primitive
abundant odd numbers whose prime divisors compose $P$.
\end{theorem}
% The algorithm:
%
% * Set initial exponents to 1 
%
% * Check if abundant. If so check if primitive
%   * If not primitive, no abundant odds 
%		* If primitive, this is 
%
% * If b(p1^e1 p2^e2 ... pd^ed) >= 2
%		* If primitive this is an option : return true
%		* If not return false
%
%	* Check to see if any exponent increases will cause abundance
%    If any do cause abundance, check if primitive.
%    Always start with the exponents of highest 'influence'
%		 then move on to lower 'influence' exponents. influence
%    is measured by which exponents increase b(n) the most
%    Del_pos is exactly the measure of this.
%
%	* Once the first exponent which does not cause abundance is found
%    we want to check which exponents can be raised to 'infinity'
%    to eventually produce an abundant number. We raise the exponents
%    NEED TO TALK ABOUT ORDER OF INFLUENCE HERE. IN THE ALGORITHM
%    WE ASSUME INFINITE INFLUENCE IS DIRECTLY RELATED TO FINITE
%    SINGLE EXPONENT INFLUENCE? IS THIS TRUE? I DONT KNOW.
%				*Infinite influence: Take a prime-exp pair p^e -> p^infinity
%				*Finite influence  : Take a prime-exp pair p^e -> p^(e+1)
%       Are they related?
% ^ * Mixed b: Raise exponents of low influence pairs to see if they
%     mixed with others will eventually go on to infinity
% ^ * If so raise 

% THIS is going to be UGLY.
% NEW THEorem added - may be important

\textit{In the below algorithm, the sequence of primes P is indexed 
starting at 0, not 1. In other words, $P = \{p_0, p_1, ..., p_{d-1}\}$}



{\setlength{\parindent}{0cm}

\textbf{The main algorithm}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$.

\textbf{OUTPUT:} All primitive abundant odds whose prime factors
compose $P$

}


\begin{algorithmic}
%E represents exponents
\IF {$b_{\infty}(P) \leq 2$}
  \RETURN $\{\}$
\ENDIF

\STATE $E := \{e_0 = 1,e_1 = 1,...,e_n = 1\}$
\STATE $A := \{ \}$ %primitive-abunant odds

\STATE $expAbundant(P, E, A)$

\RETURN $A$

\end{algorithmic}

{\setlength{\parindent}{0cm}

\textbf{Algorithm: expAbundant}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, the exponents to those 
primes $E$, and the primitive abundants found so far, $A$.

\textbf{OUTPUT:} No output. However, $A$ will be modified.
}

\begin{algorithmic}
\IF {$b(P, E) \geq 2$}
	\IF {$primitive(P, E)$}
		\STATE $A := A \& (P,E)$
		\RETURN
	\ENDIF
	\RETURN
\ENDIF
$orderDelPos(P,E,A)$
\RETURN

\end{algorithmic}

{\setlength{\parindent}{0cm}

\textbf{Algorithm: orderDelPos}

\textbf{INPUT:} The sequence of primes 
$P = \{p_0, p_1, ..., p_{d-1}\}$, exponents $E = \{ m_0, m_1,
...\}$, the set of primitive abundant numbers found $A$.

\textbf{OUTPUT:} True or False, depending on if the algorithm found any primitive abundants.
}


\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
%Index of delta_pos in order of 
%of ascending order:
% The last element as the most influence
% G is for generate: Make this function
\STATE $G := G_{ \Delta_{+}}(P,E)$

\STATE $g := |P| - 1$ %Index in I_delta

\STATE $i_p := 0$ %Prime index

\WHILE {$g \geq 0$}
	\STATE $i_p := G[g]$

	%\STATE $\Delta_{+} := \Delta_{+}(P_{i+p})$

	\IF {$b(P,E) \Delta_{+}(P[i_p], E[i_p]) \geq 2$}
		\STATE \COMMENT{$E_{new}$ is the new exponents raising the exponent that
		allows the number to be abundant}
		\STATE $E_{new} := E$
		\STATE $E_{new}[ i_p ] := E_{new}[ i_p ] + 1 $
		
		\IF {$primitive(P, E_{new})$}
			\STATE $A := A\&(P,E)$
			\STATE $e_{found} := $ TRUE
		\ENDIF

		\STATE $g := g - 1$  
	
	\ELSE
		\STATE break;
	\ENDIF
\ENDWHILE


\IF {$i_{\Delta_+} \geq 0$}
	\STATE \COMMENT{Not all indexed exponents
	were able to make an abundant when raised one power}
	\IF {$expIncAlg(P, E, A, G, g)$}
		\STATE $e_{found} := $ TRUE
	\ENDIF
\ENDIF

\RETURN $e_found$

\end{algorithmic}
expIncAlg: Parameters - P, E, A, s

\begin{algorithmic}

\STATE $e_{found} :=$ FALSE
\STATE $g  := s$
\STATE $G = G_{\Delta_+}(P,E)$


\WHILE {$g \geq 0$}
%	\STATE \COMMENT{ exponent indicies that,when increased by 1, 
%do not change the fact that n is deficient}
	\STATE $G_{b < 2} := \{G[0], G[1], 
	                       ..., G[g],\}$

	\IF {$mb(P, E, I) \geq 2$}
		\STATE \COMMENT{When other exponents that would not normally
cause n to be abundant by themselves are increased, this
exponent combined with other exponents in the stated situation
will eventually allow n to be an abundant number. Try increasing
it.}
		\STATE $E_{new} := E$
		
		%Prime index
		\STATE $i_p := G[g]$
		\STATE $E_{new}[i_p] := E_{new}[i_p] + 1$

		% TODO: here we start at i_delt+. How can we assume this?
		% Is it okay to start from the beginning to avoid this assumption?

    % TOO HARD TO PROVE, we shold not assume

		% I think we can assume because if one exponet prime sequence changes,
		% then I shifts over none or by one. If none, we are double
		% checking the prime-exp-pair
		% otherwise should we move back one or is this fine?

		%                                           _ | _
		%                                            \|/
    %                                             .
		\IF {$OrderDelPos(P, E_{new}, A$}%, g)$}
			\STATE $e_{found} :=$ TRUE
		\ENDIF

	\STATE $g :=  g - 1$
	\ENDIF

\ENDWHILE

\RETURN $e_{found}$

\end{algorithmic}


TODO: DISCUSSION ON HOW THIS ALGORITHM WORKS?

\begin{proof}
  In order to prove that this theorem we need to show that it
"Collects" all odd primitive abundant numbers whose prime factors
compose $P$. Suppose that $P = \{p_0, p_1, ..., p_{d-1}\}$.

  Let $n$ be an odd primitive abundant number whose divisors
compose $P$. We want to show that $n$ is gathered by the
algorithm, as this would prove our theorem.
\\

  First suppose that $n = p_0 p_1 ... p_{d-1}$. Upon
initialization of the algorithm, we will have that $b(n) \geq 2$,
and hence the algorithm will collect $n$.
\\

  Now suppose that $n$ has at least one prime factor with
multiplicity greater than one. Thus $n$ will have the divisor 
$d = p_0 p_1 ... p_{d-1}$, a deficient number. Hence
$b_1(P) < 2$. For convienience, we write $n = p_0^{m_0} p_1^{m_1} ...
p_{d-1}^{m_{d-1}}$ = (P,E). where at least one exponent
$m_i$ is greater than or equal to $2$.
\\

  Suppose, to the contrary, that $n$ is not obtained with the above 
algorithm, where $n$ is primitive (When this algorithm runs, we 
will have that $(P,E) \notin A$). Note that all divisors of order
$1$ (with respect to $n$) will be deficient numbers. Trivially, 
we have that the algorithm 'passes'\footnotemark a first order 
divisor or it does not pass a first order divisor. We will break 
by cases, depending on if the algorithm 'passes' a first order 
divisor.
\\

\footnotetext{What we mean by 'passes' is the following: The
algorithm 'passes' $d = p_0^{e_0} p_1^{e_1} ... p_{d-1}^{e_{d-1}}$ 
if ,at some point, the algorithm has stored the exponents of $d$
in either $E$ or $E'$. In other words: $d$ existed as $P,E$ in the
algorithm}

\textbf{Case 1:}
  Suppose the algorithm passes some first order divisor. Call
this divisor $n'$, and note that it is in the form $n'= p_0^{m_0}
p_1^{m_1} ... p_i^{m_i - 1} ... p_{d-1}^{m_{d-1}}$. This would be
represented in the algorithm as $(P, E' = \{m_0, m_1, ..., m_i - 1,
..., m_{d - 1 }\})$. 
\\

  $E'$ can occurr for the first time at one of three possible 
places: In $expAbundant$, $orderDelPos$ or $ExpIncAlg$.
\\

\textbf{Case 1.1:}  
  Suppose that the algorithm passed $E'$ in expAbundant. If this
is the case, then all of the exponents in the prime factorization
of $n'$ are $1$. This is because the algorithm constructs $E'$ as
$E' = \{1,1,1,..\}$ in $expAbundant$. As this is a deficient number, 
$b(P,E) < 2$, the $expAbundant$ will call the function 
$orderDelPos(P,E,A)$.
\\

  Let us define a \textit{crucial exponent} in the following
manner. Suppose $e_i$ is the exponent to prime $p_i$ in $n =
p_0^{e_0} p_1^{e_1} ... p_i^{e_i} ... p_{d-1}^{e_{d-1}}$. If 
$n' = p_0^{e_0} ... p_i^{e_i + 1} ... p_{d-1}^{e_{d-1}}$
is abundant, then $e_i$ is called crucial exponent with respect to
$n$.
\\

  It is appropriate to talk about how the while loop in 
$orderDelPos$ works. Consider $\ell = p_0^{e_0} ...
p_{d-1}^{e_{d-1}}$. Notice that $G = G(P,E_{\ell})$ orders the
indicies ${1,2,....,d-1}$ such that: If $i$ appears before $j$ 
in G, then $\Delta_+(p_i, e_i) \leq \Delta_+(p_j, e_j)$. This
implies the following statement: if $b(\ell) \Delta_+(p_i, e_i) 
\geq 2$, then $b(\ell) \Delta_+(p_j, e_j) \geq b(\ell)
\Delta_+(p_i,e_i) \geq 2$. Thus if $\ell_i = 
p_0^{e_0} p_1^{e_1} ... p_{i}^{e_i + 1} ... p_{d-1}^{e_{d-1}}$ 
is abundant, then 
$\ell_j = p_0^{e_0} p_1^{e_1} ... p_{j}^{e_j + 1} ... p_{d-1}^{e_{d-1}}$ 
is abundant. Finally, if $e_i$ is a crucial exponent, then $e_j$ 
is a crucial exponent.
\\

  The above fact allows us to conclude that the while loop will not
terminate until it has increased every crucial exponent. Notice
that, in our original $n'$, we have that $e_i$ is a crucial
exponent. Therefore, $e_i$ will be increased, which will result in
us obtaining $n$. However, this is a contradiction, as we assumed
the algorithm would not gather $n$.
\\

\textbf{Case 1.2:}
  Suppose that the algorithm creates $E'$ for the first time in
$orderDelPos$. If this is the case, then $E'$ must have satisfied
the condition that $n' = (P,E)$ is an abundant number. This must
be false as $n'$ is a divisor of $n$, so we have a contradiction.
\\

\textbf{Case 1.3:}
  Suppose that the algorithm creates $E'$ for the first time in
$expIncAlg$. Notice that immediently after $E'$ is created,
$OrderDelPos(P,E',A)$ is called. This brings us back to Case 1.1, 
where we have seen the crucial exponent $e_i$ must be increased by 
one, which allows the algorithm to collect $n$. This is a desired
contradiction.
\\

\textbf{Case 2:}
  If the algorithm does not pass any of the first-order divisors,
then we want use this information to show that the algorithm will
pass none of the divisors. This is an absurdity, as the
algorithm is guaranteed to pass the divisor $p_0 p_1 ... p_{d-1}$.
\\

  In order to prove that the algorithm will find none of the
divisors of $n$, we will use finite induction. Our base case is
that the algorithm does not pass any first order divisors, which
we have assumed is true(This is case 2). Our inductive step is as
follows:

\textit{Let $k \geq 1$. Suppose all divisors of order $k$ do not
show up in the algorithm. We want to show that all divisors of
order $k + 1$ do not show up in the algorithm}.
\\

  We already have the base case proven, as it was assumed as a part
of Case 2. We need to show that the inductive step is true, and we
can do this via contradiction. If the following statement leads to
a contradiction, then the inductive step is true:

\textit{Suppose a divisors of order $k + 1$ is passed in the
algorithm, yet all divisors of order $k$ are not passed in the
algorithm.}

Thus we assume that a divisor of order $k + 1$ is passed in the
algorithm. Denote this as $n_{k+1} = (P, E_{k + 1})$. 
\\

We have that $n_{k + 1}$ can occur for the first time in
$expAbundant$, $orderDelPos$ or $expIncAlg$. Here we divide these
into cases.
\\

%$$n^{(v+1)'}  = p_0^{m_0} p_1^{m_1} ...
%p_{i_1}^{m_{i_1} - l_1} ... p_{i_2}^{m_{i_2} - l_2} ... ...
%p_{i_k}^{m_{i_K} - l_k} ... p_{d-1}^{m_{d-1}}$$
%where $\sum_{1 \leq j
%\leq k} l_j = v + 1$.

\textbf{Case 2.1:} 
  Suppose that the algorithm creates $E_{k+1}$ for the first time in
$expAbundant$. Then $n_{(k+1)} = p_0^1 p_1^1 ... p_{d-1}^1$.
Notice that $n_{k + 1} | n_{k} | n$ for some $k$th order divisor
of $n$. Also, $n_k$ is a proper divisor of $n$, and therefore
$n_k$ is deficient.
\\


  The algorithm will call $orderDelPos$, as $n_{k+1}$ is 
deficient. Notice that the algorithm will eventually
call $expIncAlg(P, E_{k+1}, A)$ in $orderDelPos$. We claim this
because there exists an exponent $e_i$ which is not a crucical 
exponent*.

(* We know this
because there exists a divisor of order $n_k$ such that $n_{k + 1}
| n_k$. Thus $n_k / n_{k+1} = p_i$, and hence increasing $e_i$ in
$n_{k + 1}$ will result in a deficient number. Thus $e_i$ is not
crucial.)
\\

  Once the algorithm calls $expIncAlg$ for the first time, we
will have that all indicies after $g$ in $G$ are crucial 
exponents. All incomplete exponents must lie before $g$, for if
one of the incomplete exponents was a crucial exponent, we would
have that $n_{k + 1}$ is a first order divisor, yet $k \geq 1$ so
$n_{k+1}$ has at least order $2$. Again, we conclude that all
incomplete exponents must lie before $g$. 
\\

  All incomplete exponents lie before $g$. Therefore,
all incomplete exponents are contained in $G_{b>2}$. We know that
when the incomplete exponents are increased to a high enough
power, then the result will be $n$ or a multiple of $n$, and
therefore $mb(P,E_{k+1},G_{b<2}) > 2$. Thus the loop will
continue, and we are concerned with the first instance such that
$e_g$ is an incomplete exponent. Notice that when this is the
case, we will still have that $mb(P,E_{k+1},G_{b<2}) > 2$. 
Because of this, the algorithm will increase the exponent $e_g$,
which will result in a divisor of order $k$ with respect to $n$.
This is a desired contradiction.
\\

\textbf{Case 2.2:}
Impossible, for the same reason as \textit{Case 1.1}.
\\

\textbf{Case 2.3:}
If $n_{(v+1)}$ is discovered here , then it will be passed into
$orderDelPos$, which will bring us back to case 2.1. All the logic
will be the same, the only difference is the exponents are not all
$1$.
\\

Hence, we have that no divisors of $n$ can be discovered in the
algorithm. However, this
contradicts the fact that $p_0 p_1 p_2 ... p_{d-1}$ is a divisor
of $n$ discovered in the algorithm, thus the assumption of case 2 
must be false.
\\

In case 1 and case 2, we found that both conditions were false.
However, the cases were logical compliments, and both cannot be
false. Our assumption was that $n$ was not discovered in
the algorithm caused a contradiction, therefore $n$ must be
discovered in the algorithm. This proves the theorem.

\end{proof}

\subsection{Properties of the Exponent Algorithm}

\begin{theorem}[Property 1]

\end{theorem}

\begin{conj}[Continuity of Primative Abundant Numbers]:
Let $q \leq r$ be primes. Suppose that $p_0, p_1, p_2, ..., 
p_{l-2}, q$ are the first l divisors of some primitive abundant
odd with $d$ prime divisors. Suppose $p_0, p_1, ..., p_{l-2},r$ 
are also the first $l$ divisors of some primitive abundant odd
with $d$ prime divisors. Then, given any prime $s$ such that $q \leq s 
\leq r$, we have that $p_0, p_1,..., p_{l-2}, s$ are the first $l$
divisors of some primitive abundant odd with $d$ divisors.
\end{conj}

THIS PROPERTY IS FALSE.
\\

The below paragraphs are in construction. Be warned!!
\\

%NOTE THAT $3 * 5^6 * 7^3 * 67 * 73$ IS PRIMITIVE ABUNDANT,
%AND $3^2 * 5 * 7 * 107 * 109$ IS PRIMITIVE ABUNDANT,
%YET NO PRIMITIVE ABUNDANT WITH 5 DIVISORS EXISTS SUCH THAT
%ITS FIRST FOUR DIVISORS ARE $3,5,7$ AND $71$

%SOURCE: VAKDAS DICIUNAS,
%$https://klevas.mif.vu.lt/~valdas/Abundant_Numbers/$

%Notice that we are not far off. We are only missing about
%2 percent. And the exponent algorithm is in good condition.
%Great sifting assumption.


%IDEA IDEA IDEA!!
%Suppose that $p_1 ... p_{i-1} q$ fails in the opm algorithm. IDEA:
%We should find the maximum prime $q'$ such that $$p_1 ... p_{i-1}
%q' \in opm(i)$$. T
%hen we can start at that prime!!(Maybe )
%(Possibly)

%Why this idea?? 

Consider the example above, where $\{3,5,7,73\}$ fails.
Note that $\{3,5,7,73\} \in opm(4)$. In fact, \textit{the first
prime after q' = 103 is 107}, and note that this prime will form a
primitive abundant number in opm(5) with $3,5,7$. Thats the
conjecture.


The idea is that if the primest does not appear in opm(i), then it
is not going to create an abundant number without another prime in
d > i. We also may be able to prove that the last few primes q' in
opm(i) are going to create nonprimitive abundants.
\\

%CITE VALDAS for opm - odd primitive abundants.

Here is an important theorem

\textit{Suppose that $p_0, p_1, p_2, ..., 
p_{d-2}, q$ are the divisors of some primitive abundant
odd with $d$ prime divisors. Suppose $p_0, p_1, ..., p_{d-2},r$ 
are also the divisors of some primitive abundant odd
with $d$ prime divisors. Then, given any prime $s$ such that $q \leq s 
\leq r$, we have that $p_0, p_1,..., p_{d-2}, s$ are the 
divisors of some primitive abundant odd with $d$ divisors.}

Note that since each sequence
of primes will produce a primitive abundant number, we have that
the exponent algorithm will produce all possible combinations of
exponents that create abundant numbers for the prime sequences $Q = 
\{p_0, p_1, ..., p_{d-2}, q\}$ and $R = \{p_0, p_1, ..., p_{d-2},
r\}$. Also, notice that both Q and R will have the same initial
$G_{\Delta_+}$ values when used with the initial exponent sequence
in the exponent algorithm. And as the primes are in increasing
order, the $G_{\Delta_+}$ values are going to be exactly the same
for Q and R, and in fact (giving q and r indicies of d-1) we have
that $G_{\Delta_+}(Q, \{1,1,1,...\}) = G_{\Delta_+}(R,
\{1,1,1,...\}) = \{(d-1), (d-2), ..., 1, 0\}$. Because of this,
the exponent algorithm will follow the same path for a while for
both $Q$ and $R$.

Suppose first that $Q$ and $R$ both hit an abundant number without
diverging. Then using the same exponent set, $S$ will be
primitive.

\textbf{CASE 2:}

Now suppose that $Q$ hits an abundant and $R$ has not, yet the
algorithm has not diverged. 

\textbf{CASE 2.1}

Suppose first that $S$ is abundant
with exponents generated by $Q$'s algorithm path. Then $S$ will be
primitive with the exponents generated, for if not, we have that
a divisor of $S,E$ is going to be primitive abundant. We do not
care if this divsor shares the same prime factors, we only care if
the primitive abundant divisors are missing a prime factor: In
this case, we will have that $b(d = p_0^{m_0} ... p_{i-1}^{m_{i-1}}
p_{i + 1}^{m_{i+1}}... p_{d-2}^{m_{d-2}} s^{m_{d-1}}) > 2$,
however, it is easy to show that this divisor $d$ is such that
$b(d) < b(p_0^{m_0} p_1^{m_1} ... p_{d-2}^{m_{d-2}}) < 2$, as the
entry on the right of the equality is a divisor of our primitive
abundant odd generated by $Q,E$. Thus $S,E$ (or one of its
divisors) is primitive abundant number(with primes composing $P$).

\textbf{CASE 2.2}

%THIS CASE ALSO COVERS WHEN $Q$ AND $R$ DIVERGE EARLY, SO THE BASE
%CASE SHOULD BE DONE!

What would happen if $S,E$ is not abundant when $Q,E$ is?

Set $E$ to be the exponent set of the primitive abundant number
whose prime divisors compose $R$.

Suppose that $S,E$ is an abundant number but is not primitive and
none of its divisors who lose no prime factors are primitive. Then
$S,E$ has abundant divisor $d = p_0^{m_0} ... p_{i-1}^{m_{i-1}}
p_{i+1}^{m_{i+1}} ... s^{m_{d-1}}$. Note that this divisor has the
following property:

$$b(d) < b(p_0^{m_0} p_1^{m_1} ... p_{d-1}^{m_{d-1}}) < 2$$

And this is the case as the divisor in the middle is a proper
divisor of primitive abundant $R,E$.


%% CONJECTURE: FIRST FIND IN THE ALGORITHM WILL NOT BE TURNED DOWN 

\end{document}
